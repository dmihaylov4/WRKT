//
//  WorkoutEntry.swift
//  WRKT
//
//  Created by Dimitar Mihaylov on 26.10.25.
//

import Foundation
import SwiftUI

// MARK: - Weight Unit
enum WeightUnit: String, CaseIterable, Codable {
    case kg, lb
}

// MARK: - Set Tag
enum SetTag: String, Codable, CaseIterable {
    case warmup, working, backoff

    var label: String {
        switch self {
        case .warmup:  return "Warm-up"
        case .working: return "Working"
        case .backoff: return "Back-off"
        }
    }
    var short: String {
        switch self {
        case .warmup:  return "WU"
        case .working: return "WK"
        case .backoff: return "BO"
        }
    }
    var color: Color {
        let accent = Color(hex: "#F4E409")
        switch self {
        case .warmup:  return .blue.opacity(0.35)
        case .working: return accent.opacity(0.35)
        case .backoff: return .purple.opacity(0.35)
        }
    }
    func next() -> SetTag {
        let all = Self.allCases
        let i = all.firstIndex(of: self)!
        return all[(i + 1) % all.count]
    }
}

// MARK: - Tracking Mode
enum TrackingMode: String, Codable, CaseIterable {
    case weighted      // reps + weight (traditional strength training)
    case timed         // duration only (holds, planks, etc.)
    case bodyweight    // reps only, no weight (pull-ups, push-ups, etc.)
    case distance      // distance-based (running, cycling - future)

    var label: String {
        switch self {
        case .weighted:    return "Weighted"
        case .timed:       return "Timed"
        case .bodyweight:  return "Bodyweight"
        case .distance:    return "Distance"
        }
    }
}

// MARK: - Set Input
struct SetInput: Hashable, Codable {
    var reps: Int
    var weight: Double
    var tag: SetTag = .working
    // When true, row is allowed to overwrite weight with suggestions.
    // Flip to false as soon as user edits weight manually.
    var autoWeight: Bool = true
    var didSeedFromMemory: Bool = false
    // Track whether this set has been completed
    var isCompleted: Bool = false
    // Track if this is a ghost set (from planned workout)
    var isGhost: Bool = false
    // Track if this set was auto-generated after rest timer (safe to silently delete if untouched)
    var isAutoGeneratedPlaceholder: Bool = false

    // MARK: - Multi-Modal Tracking Support
    /// Duration in seconds for timed exercises (planks, holds, etc.)
    var durationSeconds: Int = 0
    /// Tracking mode determines which fields are relevant
    var trackingMode: TrackingMode = .weighted

    // Custom decoder to handle missing fields in old data
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        reps = try container.decode(Int.self, forKey: .reps)
        weight = try container.decode(Double.self, forKey: .weight)
        tag = (try? container.decode(SetTag.self, forKey: .tag)) ?? .working
        autoWeight = (try? container.decode(Bool.self, forKey: .autoWeight)) ?? true
        didSeedFromMemory = (try? container.decode(Bool.self, forKey: .didSeedFromMemory)) ?? false
        isCompleted = (try? container.decode(Bool.self, forKey: .isCompleted)) ?? false
        isGhost = (try? container.decode(Bool.self, forKey: .isGhost)) ?? false
        isAutoGeneratedPlaceholder = (try? container.decode(Bool.self, forKey: .isAutoGeneratedPlaceholder)) ?? false

        // NEW: Default values for multi-modal tracking (backward compatible)
        durationSeconds = (try? container.decode(Int.self, forKey: .durationSeconds)) ?? 0
        trackingMode = (try? container.decode(TrackingMode.self, forKey: .trackingMode)) ?? .weighted
    }

    // Memberwise init for creating new instances
    init(
        reps: Int,
        weight: Double,
        tag: SetTag = .working,
        autoWeight: Bool = true,
        didSeedFromMemory: Bool = false,
        isCompleted: Bool = false,
        isGhost: Bool = false,
        isAutoGeneratedPlaceholder: Bool = false,
        durationSeconds: Int = 0,
        trackingMode: TrackingMode = .weighted
    ) {
        self.reps = reps
        self.weight = weight
        self.tag = tag
        self.autoWeight = autoWeight
        self.didSeedFromMemory = didSeedFromMemory
        self.isCompleted = isCompleted
        self.isGhost = isGhost
        self.isAutoGeneratedPlaceholder = isAutoGeneratedPlaceholder
        self.durationSeconds = durationSeconds
        self.trackingMode = trackingMode
    }

    // MARK: - Computed Properties
    /// Display value that adapts to tracking mode
    var displayValue: String {
        switch trackingMode {
        case .weighted:
            return "\(reps) Ã— \(weight) kg"
        case .timed:
            return formatDuration(durationSeconds)
        case .bodyweight:
            return "\(reps) reps"
        case .distance:
            return "Distance" // TODO: Implement distance tracking
        }
    }

    /// Format duration in seconds to MM:SS or HH:MM:SS
    private func formatDuration(_ seconds: Int) -> String {
        let hours = seconds / 3600
        let minutes = (seconds % 3600) / 60
        let secs = seconds % 60

        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, secs)
        } else {
            return String(format: "%d:%02d", minutes, secs)
        }
    }
}

// MARK: - Workout Entry
struct WorkoutEntry: Identifiable, Codable, Hashable {
    var id = UUID()
    var exerciseID: String
    var exerciseName: String
    var muscleGroups: [String]
    var sets: [SetInput]
    var activeSetIndex: Int = 0  // Track which set is currently active (0-based)
}
