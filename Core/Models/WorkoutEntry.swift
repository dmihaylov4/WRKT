//
//  WorkoutEntry.swift
//  WRKT
//
//  Created by Dimitar Mihaylov on 26.10.25.
//

import Foundation
import SwiftUI

// MARK: - Weight Unit
enum WeightUnit: String, CaseIterable, Codable {
    case kg, lb
}

// MARK: - Set Tag
enum SetTag: String, Codable, CaseIterable {
    case warmup, working, backoff

    var label: String {
        switch self {
        case .warmup:  return "Warm-up"
        case .working: return "Working"
        case .backoff: return "Back-off"
        }
    }
    var short: String {
        switch self {
        case .warmup:  return "WU"
        case .working: return "WK"
        case .backoff: return "BO"
        }
    }
    var color: Color {
        let accent = Color(hex: "#CCFF00")  // Brand green
        switch self {
        case .warmup:  return .blue.opacity(0.35)
        case .working: return accent.opacity(0.35)
        case .backoff: return .purple.opacity(0.35)
        }
    }
    func next() -> SetTag {
        let all = Self.allCases
        let i = all.firstIndex(of: self)!
        return all[(i + 1) % all.count]
    }
}

// MARK: - Tracking Mode
enum TrackingMode: String, Codable, CaseIterable {
    case weighted      // reps + weight (traditional strength training)
    case timed         // duration only (holds, planks, etc.)
    case bodyweight    // reps only, no weight (pull-ups, push-ups, etc.)
    case distance      // distance-based (running, cycling - future)

    var label: String {
        switch self {
        case .weighted:    return "Weighted"
        case .timed:       return "Timed"
        case .bodyweight:  return "Bodyweight"
        case .distance:    return "Distance"
        }
    }
}

// MARK: - Set Input
struct SetInput: Hashable, Codable {
    var reps: Int
    var weight: Double
    var tag: SetTag = .working
    // When true, row is allowed to overwrite weight with suggestions.
    // Flip to false as soon as user edits weight manually.
    var autoWeight: Bool = true
    var didSeedFromMemory: Bool = false
    // Track whether this set has been completed
    var isCompleted: Bool = false
    // Track if this is a ghost set (from planned workout)
    var isGhost: Bool = false
    // Track if this set was auto-generated after rest timer (safe to silently delete if untouched)
    var isAutoGeneratedPlaceholder: Bool = false

    // MARK: - Multi-Modal Tracking Support
    /// Duration in seconds for timed exercises (planks, holds, etc.)
    var durationSeconds: Int = 0
    /// Distance in meters for distance-based exercises (running, cycling, rowing)
    var distanceMeters: Double = 0
    /// Tracking mode determines which fields are relevant
    var trackingMode: TrackingMode = .weighted

    // MARK: - Timing Data (backward compatible)
    /// When the user started this set (tapped into the set row or began timer)
    var startTime: Date?
    /// When the user completed/logged this set
    var completionTime: Date?
    /// PLANNED rest duration (from rest timer setting)
    var restAfterSeconds: Int?
    /// ACTUAL rest taken (measured from completion to next set start)
    var actualRestSeconds: Int?

    // Custom decoder to handle missing fields in old data
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        reps = try container.decode(Int.self, forKey: .reps)
        weight = try container.decode(Double.self, forKey: .weight)
        tag = (try? container.decode(SetTag.self, forKey: .tag)) ?? .working
        autoWeight = (try? container.decode(Bool.self, forKey: .autoWeight)) ?? true
        didSeedFromMemory = (try? container.decode(Bool.self, forKey: .didSeedFromMemory)) ?? false
        isCompleted = (try? container.decode(Bool.self, forKey: .isCompleted)) ?? false
        isGhost = (try? container.decode(Bool.self, forKey: .isGhost)) ?? false
        isAutoGeneratedPlaceholder = (try? container.decode(Bool.self, forKey: .isAutoGeneratedPlaceholder)) ?? false

        // NEW: Default values for multi-modal tracking (backward compatible)
        durationSeconds = (try? container.decode(Int.self, forKey: .durationSeconds)) ?? 0
        distanceMeters = (try? container.decode(Double.self, forKey: .distanceMeters)) ?? 0
        trackingMode = (try? container.decode(TrackingMode.self, forKey: .trackingMode)) ?? .weighted

        // Timing data (backward compatible)
        startTime = try? container.decode(Date.self, forKey: .startTime)
        completionTime = try? container.decode(Date.self, forKey: .completionTime)
        restAfterSeconds = try? container.decode(Int.self, forKey: .restAfterSeconds)
        actualRestSeconds = try? container.decode(Int.self, forKey: .actualRestSeconds)
    }

    // Memberwise init for creating new instances
    init(
        reps: Int,
        weight: Double,
        tag: SetTag = .working,
        autoWeight: Bool = true,
        didSeedFromMemory: Bool = false,
        isCompleted: Bool = false,
        isGhost: Bool = false,
        isAutoGeneratedPlaceholder: Bool = false,
        durationSeconds: Int = 0,
        distanceMeters: Double = 0,
        trackingMode: TrackingMode = .weighted,
        startTime: Date? = nil,
        completionTime: Date? = nil,
        restAfterSeconds: Int? = nil,
        actualRestSeconds: Int? = nil
    ) {
        self.reps = reps
        self.weight = weight
        self.tag = tag
        self.autoWeight = autoWeight
        self.didSeedFromMemory = didSeedFromMemory
        self.isCompleted = isCompleted
        self.isGhost = isGhost
        self.isAutoGeneratedPlaceholder = isAutoGeneratedPlaceholder
        self.durationSeconds = durationSeconds
        self.distanceMeters = distanceMeters
        self.trackingMode = trackingMode
        self.startTime = startTime
        self.completionTime = completionTime
        self.restAfterSeconds = restAfterSeconds
        self.actualRestSeconds = actualRestSeconds
    }

    // MARK: - Computed Properties
    /// Display value that adapts to tracking mode
    var displayValue: String {
        switch trackingMode {
        case .weighted:
            // Format weight to 1 decimal place, but remove trailing .0
            let formattedWeight = weight.truncatingRemainder(dividingBy: 1) == 0
                ? String(format: "%.0f", weight)
                : String(format: "%.1f", weight)
            return "\(reps) × \(formattedWeight) kg"
        case .timed:
            return formatDuration(durationSeconds)
        case .bodyweight:
            return "\(reps) reps"
        case .distance:
            return formatDistance(distanceMeters)
        }
    }

    /// Format duration in seconds to MM:SS or HH:MM:SS
    private func formatDuration(_ seconds: Int) -> String {
        let hours = seconds / 3600
        let minutes = (seconds % 3600) / 60
        let secs = seconds % 60

        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, secs)
        } else {
            return String(format: "%d:%02d", minutes, secs)
        }
    }

    /// Format distance in meters to human-readable string
    private func formatDistance(_ meters: Double) -> String {
        if meters >= 1000 {
            let km = meters / 1000
            return String(format: "%.2f km", km)
        } else {
            return String(format: "%.0f m", meters)
        }
    }

    // MARK: - Timing Computed Properties
    /// Active work time (completion - start)
    var workDuration: TimeInterval? {
        guard let start = startTime, let completion = completionTime else { return nil }
        return completion.timeIntervalSince(start)
    }

    /// Actual rest duration (if measured), falls back to planned rest
    var effectiveRestDuration: TimeInterval {
        if let actual = actualRestSeconds {
            return Double(actual)
        }
        return Double(restAfterSeconds ?? 0)
    }

    /// Total time for this set (work + ACTUAL rest)
    var totalSetDuration: TimeInterval? {
        guard let work = workDuration else { return nil }
        return work + effectiveRestDuration
    }

    /// Formatted work duration string (e.g., "45s", "1m 12s")
    var formattedWorkDuration: String {
        guard let duration = workDuration else { return "—" }
        return formatDurationShort(Int(duration))
    }

    /// Formatted rest duration string
    var formattedRestDuration: String {
        guard let rest = restAfterSeconds else { return "—" }
        return formatDurationShort(rest)
    }

    /// Format duration in seconds to human-readable string (e.g., "45s", "1m 30s", "1h 15m")
    private func formatDurationShort(_ seconds: Int) -> String {
        guard seconds > 0 else { return "—" }

        let hours = seconds / 3600
        let minutes = (seconds % 3600) / 60
        let secs = seconds % 60

        if hours > 0 {
            if minutes > 0 {
                return "\(hours)h \(minutes)m"
            }
            return "\(hours)h"
        } else if minutes > 0 {
            if secs > 0 {
                return "\(minutes)m \(secs)s"
            }
            return "\(minutes)m"
        } else {
            return "\(secs)s"
        }
    }

    // MARK: - Validation

    /// Validates the set input based on tracking mode
    /// Returns tuple: (isValid, errorMessage)
    func validate() -> (isValid: Bool, error: String?) {
        switch trackingMode {
        case .weighted:
            return validateWeighted()
        case .timed:
            return validateTimed()
        case .bodyweight:
            return validateBodyweight()
        case .distance:
            return validateDistance()
        }
    }

    private func validateWeighted() -> (Bool, String?) {
        // Reps must be positive
        guard reps > 0 else {
            return (false, "Reps must be greater than 0")
        }

        // Reps shouldn't be unreasonably high (likely a typo)
        guard reps <= 999 else {
            return (false, "Reps cannot exceed 999")
        }

        // Weight must be non-negative (0 is valid for deload/technique work)
        guard weight >= 0 else {
            return (false, "Weight cannot be negative")
        }

        // Weight shouldn't be unreasonably high (likely a typo)
        guard weight <= 1000 else {
            return (false, "Weight cannot exceed 1000 kg")
        }

        return (true, nil)
    }

    private func validateTimed() -> (Bool, String?) {
        // Duration must be positive
        guard durationSeconds > 0 else {
            return (false, "Duration must be greater than 0 seconds")
        }

        // Duration shouldn't be unreasonably high (12 hours = 43200 seconds)
        guard durationSeconds <= 43200 else {
            return (false, "Duration cannot exceed 12 hours")
        }

        return (true, nil)
    }

    private func validateBodyweight() -> (Bool, String?) {
        // Reps must be positive
        guard reps > 0 else {
            return (false, "Reps must be greater than 0")
        }

        // Reps shouldn't be unreasonably high
        guard reps <= 999 else {
            return (false, "Reps cannot exceed 999")
        }

        return (true, nil)
    }

    private func validateDistance() -> (Bool, String?) {
        // Distance must be positive
        guard distanceMeters > 0 else {
            return (false, "Distance must be greater than 0")
        }

        // Distance shouldn't be unreasonably high (marathon is ~42km)
        guard distanceMeters <= 100_000 else {
            return (false, "Distance cannot exceed 100 km")
        }

        // Duration must be positive (time taken)
        guard durationSeconds > 0 else {
            return (false, "Duration must be greater than 0 seconds")
        }

        guard durationSeconds <= 86400 else { // 24 hours
            return (false, "Duration cannot exceed 24 hours")
        }

        return (true, nil)
    }

    /// Quick check if the set has any meaningful data
    var hasData: Bool {
        switch trackingMode {
        case .weighted:
            return reps > 0 || weight > 0
        case .timed:
            return durationSeconds > 0
        case .bodyweight:
            return reps > 0
        case .distance:
            return distanceMeters > 0 || durationSeconds > 0
        }
    }
}

// MARK: - Workout Entry
struct WorkoutEntry: Identifiable, Codable, Hashable {
    var id = UUID()
    var exerciseID: String
    var exerciseName: String
    var muscleGroups: [String]
    var sets: [SetInput]
    var activeSetIndex: Int = 0  // Track which set is currently active (0-based)

    // MARK: - Superset Support
    var supersetGroupID: UUID? = nil
    var orderInSuperset: Int? = nil

    // Custom decoder to handle missing superset fields in old data (backward compatibility)
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(UUID.self, forKey: .id)
        exerciseID = try container.decode(String.self, forKey: .exerciseID)
        exerciseName = try container.decode(String.self, forKey: .exerciseName)
        muscleGroups = try container.decode([String].self, forKey: .muscleGroups)
        sets = try container.decode([SetInput].self, forKey: .sets)
        activeSetIndex = (try? container.decode(Int.self, forKey: .activeSetIndex)) ?? 0
        supersetGroupID = try? container.decode(UUID.self, forKey: .supersetGroupID)
        orderInSuperset = try? container.decode(Int.self, forKey: .orderInSuperset)
    }

    // Memberwise init for creating new instances
    init(
        id: UUID = UUID(),
        exerciseID: String,
        exerciseName: String,
        muscleGroups: [String],
        sets: [SetInput],
        activeSetIndex: Int = 0,
        supersetGroupID: UUID? = nil,
        orderInSuperset: Int? = nil
    ) {
        self.id = id
        self.exerciseID = exerciseID
        self.exerciseName = exerciseName
        self.muscleGroups = muscleGroups
        self.sets = sets
        self.activeSetIndex = activeSetIndex
        self.supersetGroupID = supersetGroupID
        self.orderInSuperset = orderInSuperset
    }
}

// MARK: - WorkoutEntry Superset Helpers
extension WorkoutEntry {
    /// Whether this entry is part of a superset
    var isInSuperset: Bool { supersetGroupID != nil }
}

// MARK: - WorkoutEntry Timing Extensions
extension WorkoutEntry {
    /// Total time spent on this exercise (work + rest for all sets)
    var totalDuration: TimeInterval {
        sets.compactMap { $0.totalSetDuration }.reduce(0, +)
    }

    /// Total active work time (excluding rest)
    var totalWorkTime: TimeInterval {
        sets.compactMap { $0.workDuration }.reduce(0, +)
    }

    /// Total rest time (using ACTUAL rest, not planned)
    var totalRestTime: TimeInterval {
        sets.map { $0.effectiveRestDuration }.reduce(0, +)
    }

    /// Formatted strings for display
    var formattedTotalDuration: String {
        formatTimingDuration(Int(totalDuration))
    }

    var formattedWorkTime: String {
        formatTimingDuration(Int(totalWorkTime))
    }

    var formattedRestTime: String {
        formatTimingDuration(Int(totalRestTime))
    }

    /// Format duration in seconds to human-readable string
    private func formatTimingDuration(_ seconds: Int) -> String {
        guard seconds > 0 else { return "—" }

        let hours = seconds / 3600
        let minutes = (seconds % 3600) / 60
        let secs = seconds % 60

        if hours > 0 {
            if minutes > 0 {
                return "\(hours)h \(minutes)m"
            }
            return "\(hours)h"
        } else if minutes > 0 {
            if secs > 0 {
                return "\(minutes)m \(secs)s"
            }
            return "\(minutes)m"
        } else {
            return "\(secs)s"
        }
    }
}
