//
//  WorkoutEntry.swift
//  WRKT
//
//  Created by Dimitar Mihaylov on 26.10.25.
//

import Foundation
import SwiftUI

// MARK: - Weight Unit
enum WeightUnit: String, CaseIterable, Codable {
    case kg, lb
}

// MARK: - Set Tag
enum SetTag: String, Codable, CaseIterable {
    case warmup, working, backoff

    var label: String {
        switch self {
        case .warmup:  return "Warm-up"
        case .working: return "Working"
        case .backoff: return "Back-off"
        }
    }
    var short: String {
        switch self {
        case .warmup:  return "WU"
        case .working: return "WK"
        case .backoff: return "BO"
        }
    }
    var color: Color {
        let accent = Color(hex: "#F4E409")
        switch self {
        case .warmup:  return .blue.opacity(0.35)
        case .working: return accent.opacity(0.35)
        case .backoff: return .purple.opacity(0.35)
        }
    }
    func next() -> SetTag {
        let all = Self.allCases
        let i = all.firstIndex(of: self)!
        return all[(i + 1) % all.count]
    }
}

// MARK: - Set Input
struct SetInput: Hashable, Codable {
    var reps: Int
    var weight: Double
    var tag: SetTag = .working
    // When true, row is allowed to overwrite weight with suggestions.
    // Flip to false as soon as user edits weight manually.
    var autoWeight: Bool = true
    var didSeedFromMemory: Bool = false
    // Track whether this set has been completed
    var isCompleted: Bool = false
    // Track if this is a ghost set (from planned workout)
    var isGhost: Bool = false
    // Track if this set was auto-generated after rest timer (safe to silently delete if untouched)
    var isAutoGeneratedPlaceholder: Bool = false

    // Custom decoder to handle missing fields in old data
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        reps = try container.decode(Int.self, forKey: .reps)
        weight = try container.decode(Double.self, forKey: .weight)
        tag = (try? container.decode(SetTag.self, forKey: .tag)) ?? .working
        autoWeight = (try? container.decode(Bool.self, forKey: .autoWeight)) ?? true
        didSeedFromMemory = (try? container.decode(Bool.self, forKey: .didSeedFromMemory)) ?? false
        isCompleted = (try? container.decode(Bool.self, forKey: .isCompleted)) ?? false
        isGhost = (try? container.decode(Bool.self, forKey: .isGhost)) ?? false
        isAutoGeneratedPlaceholder = (try? container.decode(Bool.self, forKey: .isAutoGeneratedPlaceholder)) ?? false
    }

    // Memberwise init for creating new instances
    init(reps: Int, weight: Double, tag: SetTag = .working, autoWeight: Bool = true, didSeedFromMemory: Bool = false, isCompleted: Bool = false, isGhost: Bool = false, isAutoGeneratedPlaceholder: Bool = false) {
        self.reps = reps
        self.weight = weight
        self.tag = tag
        self.autoWeight = autoWeight
        self.didSeedFromMemory = didSeedFromMemory
        self.isCompleted = isCompleted
        self.isGhost = isGhost
        self.isAutoGeneratedPlaceholder = isAutoGeneratedPlaceholder
    }
}

// MARK: - Workout Entry
struct WorkoutEntry: Identifiable, Codable, Hashable {
    var id = UUID()
    var exerciseID: String
    var exerciseName: String
    var muscleGroups: [String]
    var sets: [SetInput]
    var activeSetIndex: Int = 0  // Track which set is currently active (0-based)
}
