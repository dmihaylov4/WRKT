//
//  BodyweightSetRow.swift
//  WRKT
//
//  Set row component for bodyweight exercises (pull-ups, push-ups, etc.)
//  Shows only reps, no weight input
//

import SwiftUI

private typealias Theme = ExerciseSessionTheme

// MARK: - Bodyweight Set Row

struct BodyweightSetRow: View {
    let index: Int
    @Binding var set: SetInput
    let exercise: Exercise
    let isActive: Bool
    let isGhost: Bool
    let hasActiveTimer: Bool
    let onActivate: () -> Void
    let onLogSet: () -> Void

    @EnvironmentObject private var store: WorkoutStoreV2
    @ObservedObject private var timerManager = RestTimerManager.shared

    private let defaultWorkingReps = 10

    @State private var isEditingReps = false
    @FocusState private var focusedField: Field?

    enum Field {
        case reps
    }

    var body: some View {
        VStack(spacing: 0) {
            // Header: Set number, status, and type
            HStack(spacing: 12) {
                // Set number with status indicator
                HStack(spacing: 6) {
                    if set.isCompleted {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.body.weight(.semibold))
                            .foregroundStyle(Theme.accent)
                    } else if isActive {
                        Circle()
                            .fill(Theme.accent)
                            .frame(width: 8, height: 8)
                    } else {
                        Circle()
                            .strokeBorder(Theme.secondary.opacity(0.3), lineWidth: 1.5)
                            .frame(width: 8, height: 8)
                    }

                    Text("Set \(index)")
                        .font(.subheadline.weight(isActive ? .bold : .semibold))
                        .foregroundStyle(
                            set.isCompleted && hasActiveTimer ? Theme.text.opacity(0.7) :
                            set.isCompleted ? Theme.secondary :
                            Theme.text
                        )
                }

                // Rest timer (if active for this set)
                if hasActiveTimer && timerManager.isRunning {
                    Button {
                        timerManager.stopTimer()
                        UIImpactFeedbackGenerator(style: .medium).impactOccurred()
                    } label: {
                        HStack(spacing: 4) {
                            Image(systemName: "timer")
                                .font(.caption.weight(.medium))
                            Text(formatTime(timerManager.remainingSeconds))
                                .font(.caption.monospacedDigit().weight(.semibold))
                            Text("•")
                                .font(.caption2)
                            Text("Cancel")
                                .font(.caption.weight(.semibold))
                            Image(systemName: "xmark.circle.fill")
                                .font(.caption)
                        }
                        .foregroundStyle(Theme.accent)
                        .padding(.horizontal, 10)
                        .padding(.vertical, 5)
                        .background(Theme.accent.opacity(0.15))
                        .clipShape(Capsule())
                        .overlay(Capsule().stroke(Theme.accent.opacity(0.3), lineWidth: 1))
                    }
                    .buttonStyle(.plain)
                }

                Spacer()

                // Set type badge
                TagDotCycler(tag: $set.tag)
                    .disabled(set.isCompleted || isGhost)
                    .opacity(set.isCompleted ? 0.5 : 1.0)
            }
            .padding(.horizontal, 16)
            .padding(.top, 8)
            .padding(.bottom, 6)

            Divider()
                .background(Theme.border)
                .padding(.horizontal, 16)

            // Reps input (centered, larger for bodyweight focus)
            VStack(spacing: 8) {
                Text("REPS")
                    .font(.caption.weight(.semibold))
                    .foregroundStyle(Theme.secondary)

                HStack(spacing: 12) {
                    StepperButton(
                        systemName: "minus.circle.fill",
                        isEnabled: !set.isCompleted && !isGhost && set.reps > 1,
                        color: Theme.accent.opacity(0.8)
                    ) {
                        if set.reps > 1 {
                            set.reps -= 1
                            set.isAutoGeneratedPlaceholder = false
                            UIImpactFeedbackGenerator(style: .light).impactOccurred()
                        }
                    }

                    // Tap to type - Reps (larger for bodyweight)
                    if isEditingReps {
                        TextField("", value: $set.reps, format: .number)
                            .keyboardType(.numberPad)
                            .focused($focusedField, equals: .reps)
                            .font(.system(size: 52, weight: .bold, design: .rounded))
                            .monospacedDigit()
                            .foregroundStyle(Theme.text)
                            .multilineTextAlignment(.center)
                            .frame(minWidth: 80)
                            .onChange(of: set.reps) { _, _ in
                                set.isAutoGeneratedPlaceholder = false
                            }
                    } else {
                        Text("\(set.reps)")
                            .font(.system(size: 52, weight: .bold, design: .rounded))
                            .monospacedDigit()
                            .foregroundStyle(set.isCompleted ? Theme.secondary : Theme.text)
                            .frame(minWidth: 80)
                            .contentShape(Rectangle())
                            .onTapGesture {
                                if !set.isCompleted && !isGhost {
                                    isEditingReps = true
                                    focusedField = .reps
                                }
                            }
                    }

                    StepperButton(
                        systemName: "plus.circle.fill",
                        isEnabled: !set.isCompleted && !isGhost,
                        color: Theme.accent
                    ) {
                        set.reps += 1
                        set.isAutoGeneratedPlaceholder = false
                        UIImpactFeedbackGenerator(style: .light).impactOccurred()
                    }
                }

                // Show PR or last performance if available
                if let prReps = store.personalBestReps(for: exercise) {
                    HStack(spacing: 12) {
                        if prReps > 0 {
                            Text("PR: \(prReps) reps")
                                .font(.caption.weight(.medium))
                                .foregroundStyle(Theme.secondary)
                        }

                        if let last = store.lastWorkingSet(exercise: exercise), last.reps > 0 {
                            Text("•")
                                .font(.caption2)
                                .foregroundStyle(Theme.secondary.opacity(0.5))
                            Text("Last: \(last.reps) reps")
                                .font(.caption.weight(.medium))
                                .foregroundStyle(Theme.secondary)
                        }
                    }
                    .padding(.top, 4)
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 16)

            // Active set: Show "Log This Set" button
            if isActive && !set.isCompleted && !isGhost {
                Divider()
                    .background(Theme.border)
                    .padding(.horizontal, 16)

                Button(action: onLogSet) {
                    HStack(spacing: 8) {
                        Image(systemName: "checkmark.circle.fill")
                        Text("Log This Set")
                            .fontWeight(.semibold)
                    }
                    .font(.subheadline)
                    .foregroundStyle(Color.black)
                    .frame(maxWidth: .infinity)
                    .frame(height: 44)
                    .background(Theme.accent)
                    .clipShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
                }
                .buttonStyle(.plain)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
            }
        }
        .background(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .fill(backgroundColor)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .strokeBorder(borderColor, lineWidth: isActive ? 2 : 1)
        )
        .opacity(rowOpacity)
        .animation(.easeInOut(duration: 0.2), value: isActive)
        .animation(.easeInOut(duration: 0.2), value: set.isCompleted)
        .animation(.easeInOut(duration: 0.2), value: hasActiveTimer)
        .onTapGesture {
            // Dismiss keyboard if editing, otherwise activate set
            if focusedField != nil {
                focusedField = nil
                isEditingReps = false
            } else if !set.isCompleted {
                set.isAutoGeneratedPlaceholder = false
                onActivate()
            }
        }
        .onChange(of: focusedField) { _, newValue in
            if newValue != .reps {
                isEditingReps = false
            }
        }
        .onAppear {
            seedFromMemoryIfNeeded()
        }
    }

    // MARK: - Styling

    private var backgroundColor: Color {
        if set.isCompleted && hasActiveTimer {
            return Theme.accent.opacity(0.08)
        } else if set.isCompleted {
            return Theme.accent.opacity(0.04)
        } else if isActive {
            return Theme.surface2
        } else {
            return Theme.surface
        }
    }

    private var borderColor: Color {
        if set.isCompleted && hasActiveTimer {
            return Theme.accent.opacity(0.5)
        } else if set.isCompleted {
            return Theme.accent.opacity(0.2)
        } else if isActive {
            return Theme.accent
        } else {
            return Theme.border
        }
    }

    private var rowOpacity: Double {
        if set.isCompleted && hasActiveTimer {
            return 0.85
        } else if set.isCompleted {
            return 0.65
        } else {
            return 1.0
        }
    }

    // MARK: - Helpers

    private func seedFromMemoryIfNeeded() {
        guard set.tag == .working, !set.didSeedFromMemory else { return }
        let looksEmpty = (set.reps == 0 && set.weight == 0)
        guard looksEmpty else { return }

        if let last = store.lastWorkingSet(exercise: exercise) {
            set.reps = last.reps
            set.weight = 0 // Always 0 for bodyweight
            set.didSeedFromMemory = true
            return
        }

        set.reps = (set.reps > 0) ? set.reps : defaultWorkingReps
        set.weight = 0
        set.didSeedFromMemory = true
    }

    private func formatTime(_ seconds: TimeInterval) -> String {
        let mins = Int(seconds) / 60
        let secs = Int(seconds) % 60
        return String(format: "%d:%02d", mins, secs)
    }
}

// MARK: - Stepper Button (Reused from SetRowViews)

private struct StepperButton: View {
    let systemName: String
    let isEnabled: Bool
    let color: Color
    let action: () -> Void

    @GestureState private var isPressingDown = false
    @State private var longPressTimer: Timer?

    var body: some View {
        Image(systemName: systemName)
            .font(.title2)
            .foregroundStyle(isEnabled ? color : Theme.secondary.opacity(0.3))
            .frame(width: 44, height: 44)
            .contentShape(Rectangle())
            .gesture(
                DragGesture(minimumDistance: 0)
                    .updating($isPressingDown) { _, state, _ in
                        state = true
                    }
                    .onChanged { _ in
                        if isEnabled && longPressTimer == nil {
                            action()
                            UIImpactFeedbackGenerator(style: .light).impactOccurred()

                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                                if isPressingDown && isEnabled {
                                    startLongPress()
                                }
                            }
                        }
                    }
            )
            .onChange(of: isPressingDown) { _, pressing in
                if !pressing {
                    stopLongPress()
                }
            }
    }

    private func startLongPress() {
        guard longPressTimer == nil else { return }
        UIImpactFeedbackGenerator(style: .medium).impactOccurred()

        longPressTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
            if isEnabled {
                action()
            } else {
                stopLongPress()
            }
        }
    }

    private func stopLongPress() {
        longPressTimer?.invalidate()
        longPressTimer = nil
    }
}
