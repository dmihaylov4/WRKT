//
//  SocialProfileView.swift
//  WRKT
//
//  Social user profile view with workout posts and stats
//

import SwiftUI
import PhotosUI
import SwiftData
import Kingfisher

@MainActor
@Observable
final class ProfileViewModel {
    var profile: UserProfile
    var posts: [WorkoutPost] = []
    var isLoadingPosts = false
    var isUploadingAvatar = false
    var selectedPhoto: PhotosPickerItem?
    var error: String?
    var friendCount: Int = 0

    // Friend status
    var friendshipStatus: ProfileFriendshipStatus = .none
    var currentFriendship: Friendship?
    var isLoadingFriendship = false

    private let postRepository: PostRepository
    private let friendshipRepository: FriendshipRepository
    private let imageUploadService: ImageUploadService
    private let authService: SupabaseAuthService

    var isOwnProfile: Bool {
        profile.id == authService.currentUser?.id
    }

    init(
        profile: UserProfile,
        postRepository: PostRepository,
        friendshipRepository: FriendshipRepository,
        imageUploadService: ImageUploadService,
        authService: SupabaseAuthService
    ) {
        self.profile = profile
        self.postRepository = postRepository
        self.friendshipRepository = friendshipRepository
        self.imageUploadService = imageUploadService
        self.authService = authService
    }

    func loadUserPosts() async {
        guard !isLoadingPosts else { return }

        isLoadingPosts = true
        error = nil

        do {
            posts = try await postRepository.fetchUserPosts(userId: profile.id)
            isLoadingPosts = false
        } catch {
            self.error = error.localizedDescription
            isLoadingPosts = false
        }
    }

    func loadFriendCount() async {
        do {
            let friends = try await friendshipRepository.fetchFriends(userId: profile.id)
            friendCount = friends.count
        } catch {
            friendCount = 0
        }
    }

    func loadFriendshipStatus() async {
        guard !isOwnProfile else { return }
        guard let currentUserId = authService.currentUser?.id else { return }

        isLoadingFriendship = true

        do {
            let friendship = try await friendshipRepository.checkFriendshipStatus(
                userId: currentUserId,
                friendId: profile.id
            )

            currentFriendship = friendship

            // Map database status to view status
            if let friendship = friendship {
                switch friendship.status {
                case .accepted:
                    friendshipStatus = .friends
                case .pending:
                    // Determine if pending is sent or received based on user_id
                    if friendship.userId == currentUserId {
                        friendshipStatus = .pendingSent
                    } else {
                        friendshipStatus = .pendingReceived
                    }
                case .blocked:
                    friendshipStatus = .none
                }
            } else {
                friendshipStatus = .none
            }

            isLoadingFriendship = false
        } catch {
            isLoadingFriendship = false
        }
    }

    func sendFriendRequest() async {
        guard let currentUserId = authService.currentUser?.id else { return }

        isLoadingFriendship = true

        do {
            try await friendshipRepository.sendFriendRequest(to: profile.id, from: currentUserId)
            friendshipStatus = .pendingSent
            isLoadingFriendship = false
            Haptics.success()
        } catch {
            self.error = "Failed to send friend request"
            isLoadingFriendship = false
            Haptics.error()
        }
    }

    func acceptFriendRequest() async {
        guard let friendshipId = currentFriendship?.id else { return }

        isLoadingFriendship = true

        do {
            let updatedFriendship = try await friendshipRepository.acceptFriendRequest(friendshipId: friendshipId)
            currentFriendship = updatedFriendship
            friendshipStatus = .friends
            isLoadingFriendship = false
            Haptics.success()
        } catch {
            self.error = "Failed to accept friend request"
            isLoadingFriendship = false
            Haptics.error()
        }
    }

    func removeFriend() async {
        guard let friendshipId = currentFriendship?.id else { return }

        isLoadingFriendship = true

        do {
            try await friendshipRepository.removeFriend(friendshipId: friendshipId)
            currentFriendship = nil
            friendshipStatus = .none
            isLoadingFriendship = false
            Haptics.success()
        } catch {
            self.error = "Failed to remove friend"
            isLoadingFriendship = false
            Haptics.error()
        }
    }

    func uploadProfilePicture() async {
        guard let selectedPhoto = selectedPhoto else { return }
        guard let currentUserId = authService.currentUser?.id else { return }

        isUploadingAvatar = true
        error = nil

        do {
            // Load image from PhotosPicker
            guard let imageData = try await selectedPhoto.loadTransferable(type: Data.self),
                  let image = UIImage(data: imageData),
                  let jpegData = image.jpegData(compressionQuality: 0.8),
                  let finalImage = UIImage(data: jpegData) else {
                throw SupabaseError.serverError("Failed to load image")
            }

            // Upload to storage
            let avatarUrl = try await imageUploadService.uploadProfilePicture(
                image: finalImage,
                userId: currentUserId
            )

            // Save to database and update local state
            try await authService.updateProfile(avatarUrl: avatarUrl)

            // Update local profile state
            var updatedProfile = profile
            updatedProfile.avatarUrl = avatarUrl
            profile = updatedProfile

            isUploadingAvatar = false
            self.selectedPhoto = nil
            Haptics.success()
        } catch {
            self.error = "Failed to upload profile picture: \(error.localizedDescription)"
            isUploadingAvatar = false
            Haptics.error()
        }
    }
}

enum ProfileFriendshipStatus {
    case none
    case friends
    case pendingSent
    case pendingReceived
}

struct SocialProfileView: View {
    @Environment(\.dependencies) private var deps
    @Environment(\.dismiss) private var dismiss
    @Query private var progress: [RewardProgress]

    let userId: UUID

    @State private var viewModel: ProfileViewModel?
    @State private var showingEditProfile = false
    @State private var showingRemoveFriendAlert = false
    @State private var loadError: String?

    var body: some View {
        Group {
            if let error = loadError {
                errorView(error: error)
            } else if let viewModel = viewModel {
                content(viewModel: viewModel)
            } else {
                // Show skeleton loading state
                ScrollView {
                    SkeletonProfileHeader()
                        .padding(.bottom, 20)

                    // Skeleton posts section
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Workouts")
                            .font(.headline)
                            .foregroundStyle(DS.Semantic.textPrimary)
                            .padding(.horizontal)

                        ForEach(0..<2, id: \.self) { _ in
                            SkeletonPostCard()
                                .padding(.horizontal)
                        }
                    }
                }
            }
        }
        .navigationTitle("Profile")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            if viewModel == nil {
                await loadProfile()
            }
        }
    }

    private func loadProfile() async {
        // Try to get profile from cache first (if viewing own profile)
        if userId == deps.authService.currentUser?.id,
           let currentProfile = deps.authService.currentUser?.profile {
            let vm = ProfileViewModel(
                profile: currentProfile,
                postRepository: deps.postRepository,
                friendshipRepository: deps.friendshipRepository,
                imageUploadService: deps.imageUploadService,
                authService: deps.authService
            )
            viewModel = vm

            async let posts: () = vm.loadUserPosts()
            async let friendship: () = vm.loadFriendshipStatus()
            async let friends: () = vm.loadFriendCount()
            _ = await (posts, friendship, friends)
        } else {
            // Fetch profile from database for other users
            do {
                let profile = try await deps.authService.fetchProfile(userId: userId)

                let vm = ProfileViewModel(
                    profile: profile,
                    postRepository: deps.postRepository,
                    friendshipRepository: deps.friendshipRepository,
                    imageUploadService: deps.imageUploadService,
                    authService: deps.authService
                )
                viewModel = vm

                async let posts: () = vm.loadUserPosts()
                async let friendship: () = vm.loadFriendshipStatus()
                async let friends: () = vm.loadFriendCount()
                _ = await (posts, friendship, friends)
            } catch {
                loadError = "Failed to load profile: \(error.localizedDescription)"
            }
        }
    }

    private func errorView(error: String) -> some View {
        VStack(spacing: 16) {
            Image(systemName: "person.crop.circle.badge.exclamationmark")
                .font(.system(size: 60))
                .foregroundStyle(DS.Semantic.textSecondary)

            Text("Profile Not Found")
                .font(.headline)
                .foregroundStyle(DS.Semantic.textPrimary)

            Text(error)
                .font(.subheadline)
                .foregroundStyle(DS.Semantic.textSecondary)
                .multilineTextAlignment(.center)

            Button("Try Again") {
                loadError = nil
                viewModel = nil
                Task {
                    await loadProfile()
                }
            }
            .buttonStyle(.borderedProminent)
            .tint(DS.Palette.marone)
        }
        .padding()
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    @ViewBuilder
    private func content(viewModel: ProfileViewModel) -> some View {
        ScrollView {
            VStack(spacing: 24) {
                // Profile Header
                profileHeader(viewModel: viewModel)

                // Stats Row
                statsRow(viewModel: viewModel)

                // Action Buttons
                actionButtons(viewModel: viewModel)

                Divider()

                // Posts Section
                postsSection(viewModel: viewModel)
            }
            .padding()
        }
        .refreshable {
            async let posts: () = viewModel.loadUserPosts()
            async let friends: () = viewModel.loadFriendCount()
            _ = await (posts, friends)
        }
        .sheet(isPresented: $showingEditProfile) {
            EditProfileView(profile: viewModel.profile) { updatedProfile in
                viewModel.profile = updatedProfile
            }
        }
        .alert("Remove Friend", isPresented: $showingRemoveFriendAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Remove", role: .destructive) {
                Task {
                    await viewModel.removeFriend()
                }
            }
        } message: {
            Text("Are you sure you want to remove \(viewModel.profile.username) from your friends?")
        }
    }

    private func profileHeader(viewModel: ProfileViewModel) -> some View {
        VStack(spacing: 16) {
            // Profile Picture
            ZStack(alignment: .bottomTrailing) {
                KFImage(URL(string: viewModel.profile.avatarUrl ?? ""))
                    .placeholder {
                        Circle()
                            .fill(DS.Semantic.brandSoft)
                            .overlay(
                                Text(viewModel.profile.username.prefix(1).uppercased())
                                    .font(.system(size: 40, weight: .bold))
                                    .foregroundStyle(DS.Semantic.brand)
                            )
                    }
                    .fade(duration: 0.25)
                    .resizable()
                    .scaledToFill()
                    .frame(width: 100, height: 100)
                    .clipShape(Circle())
                    .overlay(
                        Circle()
                            .stroke(DS.Semantic.border, lineWidth: 2)
                    )
                    .id(viewModel.profile.avatarUrl ?? "")

                // Edit button for own profile
                if viewModel.isOwnProfile {
                    PhotosPicker(selection: Binding(
                        get: { viewModel.selectedPhoto },
                        set: { newValue in
                            viewModel.selectedPhoto = newValue
                            if newValue != nil {
                                Task {
                                    await viewModel.uploadProfilePicture()
                                }
                            }
                        }
                    ), matching: .images) {
                        ZStack {
                            Circle()
                                .fill(DS.Semantic.brand)
                                .frame(width: 32, height: 32)

                            if viewModel.isUploadingAvatar {
                                ProgressView()
                                    .tint(.black)
                            } else {
                                Image(systemName: "camera.fill")
                                    .font(.caption)
                                    .foregroundStyle(.black)
                            }
                        }
                    }
                    .disabled(viewModel.isUploadingAvatar)
                }
            }

            // Username & Display Name
            VStack(spacing: 4) {
                if let displayName = viewModel.profile.displayName, !displayName.isEmpty {
                    Text(displayName)
                        .font(.title2.bold())
                        .foregroundStyle(DS.Semantic.textPrimary)

                    Text("@\(viewModel.profile.username)")
                        .font(.subheadline)
                        .foregroundStyle(DS.Semantic.textSecondary)
                } else {
                    Text("@\(viewModel.profile.username)")
                        .font(.title2.bold())
                        .foregroundStyle(DS.Semantic.textPrimary)
                }
            }

            // Bio
            if let bio = viewModel.profile.bio, !bio.isEmpty {
                Text(bio)
                    .font(.body)
                    .foregroundStyle(DS.Semantic.textSecondary)
                    .multilineTextAlignment(.center)
            }
        }
    }

    private func statsRow(viewModel: ProfileViewModel) -> some View {
        HStack(spacing: 32) {
            statItem(value: "\(viewModel.posts.count)", label: "Workouts")
            statItem(value: "\(viewModel.friendCount)", label: "Friends")
            statItem(value: "\(progress.first?.currentStreak ?? 0)", label: "Streak")
        }
        .padding()
        .background(DS.Semantic.fillSubtle)
        .clipShape(RoundedRectangle(cornerRadius: 12))
    }

    private func statItem(value: String, label: String) -> some View {
        VStack(spacing: 4) {
            Text(value)
                .font(.title3.bold())
                .foregroundStyle(DS.Semantic.textPrimary)

            Text(label)
                .font(.caption)
                .foregroundStyle(DS.Semantic.textSecondary)
        }
    }

    private func actionButtons(viewModel: ProfileViewModel) -> some View {
        Group {
            if viewModel.isOwnProfile {
                Button {
                    showingEditProfile = true
                } label: {
                    Text("Edit Profile")
                        .font(.headline)
                        .foregroundStyle(.black)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(DS.Palette.marone)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                }
            } else {
                friendActionButton(viewModel: viewModel)
            }
        }
    }

    @ViewBuilder
    private func friendActionButton(viewModel: ProfileViewModel) -> some View {
        switch viewModel.friendshipStatus {
        case .none:
            Button {
                Task {
                    await viewModel.sendFriendRequest()
                }
            } label: {
                if viewModel.isLoadingFriendship {
                    ProgressView()
                        .tint(.black)
                } else {
                    Text("Add Friend")
                }
            }
            .buttonStyle(PrimaryButtonStyle())
            .disabled(viewModel.isLoadingFriendship)

        case .friends:
            Button {
                showingRemoveFriendAlert = true
            } label: {
                Text("Friends")
            }
            .buttonStyle(SecondaryButtonStyle())

        case .pendingSent:
            Button {
                // TODO: Cancel friend request
            } label: {
                Text("Request Sent")
            }
            .buttonStyle(SecondaryButtonStyle())
            .disabled(true)

        case .pendingReceived:
            HStack(spacing: 12) {
                Button {
                    Task {
                        await viewModel.acceptFriendRequest()
                    }
                } label: {
                    Text("Accept")
                }
                .buttonStyle(PrimaryButtonStyle())

                Button {
                    // TODO: Decline friend request
                } label: {
                    Text("Decline")
                }
                .buttonStyle(SecondaryButtonStyle())
            }
        }
    }

    private func postsSection(viewModel: ProfileViewModel) -> some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Workouts")
                .font(.headline)
                .foregroundStyle(DS.Semantic.textPrimary)

            if viewModel.isLoadingPosts {
                // Show skeleton posts while loading
                LazyVStack(spacing: 16) {
                    ForEach(0..<2, id: \.self) { _ in
                        SkeletonPostCard()
                    }
                }
            } else if viewModel.posts.isEmpty {
                VStack(spacing: 12) {
                    Image(systemName: "figure.run.circle")
                        .font(.system(size: 50))
                        .foregroundStyle(DS.Semantic.textSecondary)

                    Text("No workouts shared yet")
                        .font(.subheadline)
                        .foregroundStyle(DS.Semantic.textSecondary)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 40)
            } else {
                LazyVStack(spacing: 16) {
                    ForEach(viewModel.posts) { post in
                        // Simple post preview
                        postPreview(post: post)
                    }
                }
            }
        }
    }

    private func postPreview(post: WorkoutPost) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            if let caption = post.caption {
                Text(caption)
                    .font(.body)
                    .foregroundStyle(DS.Semantic.textPrimary)
                    .lineLimit(2)
            }

            HStack {
                Image(systemName: "figure.run")
                    .foregroundStyle(DS.Semantic.brand)
                Text(post.workoutData.workoutName ?? "Workout")
                    .font(.subheadline.bold())
                    .foregroundStyle(DS.Semantic.textPrimary)

                Spacer()

                Text(post.createdAt, style: .date)
                    .font(.caption)
                    .foregroundStyle(DS.Semantic.textSecondary)
            }

            HStack(spacing: 16) {
                Label("\(post.exerciseCount) exercises", systemImage: "dumbbell.fill")
                Label("\(post.totalSets) sets", systemImage: "list.bullet")
            }
            .font(.caption)
            .foregroundStyle(DS.Semantic.textSecondary)
        }
        .padding()
        .background(DS.Semantic.fillSubtle)
        .clipShape(RoundedRectangle(cornerRadius: 12))
    }
}

// MARK: - Button Styles

struct PrimaryButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.headline)
            .foregroundStyle(.black)
            .frame(maxWidth: .infinity)
            .padding()
            .background(DS.Palette.marone)
            .clipShape(RoundedRectangle(cornerRadius: 12))
            .opacity(configuration.isPressed ? 0.8 : 1.0)
    }
}

struct SecondaryButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.headline)
            .foregroundStyle(DS.Semantic.textPrimary)
            .frame(maxWidth: .infinity)
            .padding()
            .background(DS.Semantic.fillSubtle)
            .clipShape(RoundedRectangle(cornerRadius: 12))
            .opacity(configuration.isPressed ? 0.8 : 1.0)
    }
}

// MARK: - Edit Profile View (Placeholder)

struct EditProfileView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.dependencies) private var deps
    let profile: UserProfile
    let onProfileUpdated: (UserProfile) -> Void

    @State private var displayName: String
    @State private var bio: String
    @State private var isPrivate: Bool
    @State private var isSaving = false
    @State private var error: String?

    init(profile: UserProfile, onProfileUpdated: @escaping (UserProfile) -> Void) {
        self.profile = profile
        self.onProfileUpdated = onProfileUpdated
        _displayName = State(initialValue: profile.displayName ?? "")
        _bio = State(initialValue: profile.bio ?? "")
        _isPrivate = State(initialValue: profile.isPrivate)
    }

    var body: some View {
        NavigationStack {
            Form {
                Section("Profile Information") {
                    TextField("Display Name", text: $displayName)
                    TextField("Bio", text: $bio, axis: .vertical)
                        .lineLimit(3...6)
                }

                Section {
                    Toggle("Private Profile", isOn: $isPrivate)
                } header: {
                    Text("Privacy")
                } footer: {
                    Text("When enabled, your profile won't appear in search results. People can only find you if they already know your username.")
                        .font(.caption)
                }

                if let error = error {
                    Section {
                        Text(error)
                            .foregroundStyle(.red)
                            .font(.caption)
                    }
                }
            }
            .navigationTitle("Edit Profile")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .disabled(isSaving)
                }

                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        Task {
                            await saveProfile()
                        }
                    }
                    .disabled(isSaving)
                }
            }
        }
    }

    private func saveProfile() async {
        isSaving = true
        error = nil

        do {
            // Update profile in database
            try await deps.authService.updateProfile(
                displayName: displayName.isEmpty ? nil : displayName,
                bio: bio.isEmpty ? nil : bio,
                isPrivate: isPrivate
            )

            // Get updated profile from auth service
            if let updatedProfile = deps.authService.currentUser?.profile {
                onProfileUpdated(updatedProfile)
            }

            Haptics.success()
            dismiss()
        } catch {
            self.error = "Failed to save profile: \(error.localizedDescription)"
            isSaving = false
            Haptics.error()
        }
    }
}
