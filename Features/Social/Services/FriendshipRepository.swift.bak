import Foundation
import Supabase

/// Repository for managing friendships with query optimization
@MainActor
final class FriendshipRepository: BaseRepository<Friendship>, FriendshipRepositoryProtocol {

    init(client: SupabaseClient = SupabaseClientWrapper.shared.client) {
        super.init(
            tableName: "friendships",
            logPrefix: "Friendship",
            client: client
        )
    }

    // MARK: - Send Friend Request

    /// Send a friend request to another user
    func sendFriendRequest(to userId: UUID, from currentUserId: UUID) async throws -> Friendship {
        logInfo("Sending friend request from \(currentUserId) to \(userId)")

        // Check if friendship already exists
        let existing: [Friendship] = try await client
            .from("friendships")
            .select()
            .or("and(user_id.eq.\(currentUserId),friend_id.eq.\(userId)),and(user_id.eq.\(userId),friend_id.eq.\(currentUserId))")
            .execute()
            .value

        if let existingFriendship = existing.first {
            logWarning("Friendship already exists with status: \(existingFriendship.status)")
            throw SupabaseError.serverError("Friend request already exists")
        }

        // Create new friendship request
        struct NewFriendship: Encodable {
            let user_id: String
            let friend_id: String
            let status: String
        }

        let newFriendshipData = NewFriendship(
            user_id: currentUserId.uuidString,
            friend_id: userId.uuidString,
            status: "pending"
        )

        let newFriendship: Friendship = try await client
            .from("friendships")
            .insert(newFriendshipData)
            .select()
            .single()
            .execute()
            .value

        // Invalidate friendship caches
        cache.invalidate(QueryCache.friendsListKey(userId: currentUserId.uuidString))
        cache.invalidate(QueryCache.friendsListKey(userId: userId.uuidString))

        logSuccess("Friend request sent: \(newFriendship.id)")
        return newFriendship
    }

    // MARK: - Accept Friend Request

    /// Accept a pending friend request
    func acceptFriendRequest(friendshipId: UUID) async throws -> Friendship {
        logSuccess("Accepting friend request: \(friendshipId)")

        struct UpdateStatus: Encodable {
            let status: String
        }

        let updated: Friendship = try await client
            .from("friendships")
            .update(UpdateStatus(status: "accepted"))
            .eq("id", value: friendshipId.uuidString)
            .single()
            .execute()
            .value

        // Invalidate friendship caches
        cache.invalidateAllFriendsLists()

        logSuccess("Friend request accepted")
        return updated
    }

    // MARK: - Reject Friend Request

    /// Reject a pending friend request (deletes it)
    func rejectFriendRequest(friendshipId: UUID) async throws {
        logError("Rejecting friend request: \(friendshipId)")

        try await client
            .from("friendships")
            .delete()
            .eq("id", value: friendshipId.uuidString)
            .execute()

        // Invalidate friendship caches
        cache.invalidateAllFriendsLists()

        logSuccess("Friend request rejected")
    }

    // MARK: - Remove Friend

    /// Remove a friend (deletes the friendship)
    func removeFriend(friendshipId: UUID) async throws {
        print("ðŸ—‘ï¸ [Friendship] Removing friend: \(friendshipId)")

        try await client
            .from("friendships")
            .delete()
            .eq("id", value: friendshipId.uuidString)
            .execute()

        // Invalidate friendship caches
        cache.invalidateAllFriendsLists()

        logSuccess("Friend removed")
    }

    // MARK: - Fetch Friends

    /// Fetch all accepted friends for a user with caching
    func fetchFriends(userId: UUID) async throws -> [Friend] {
        print("ðŸ‘¥ [Friendship] Fetching friends for user: \(userId)")

        // Try cache first
        let cacheKey = QueryCache.friendsListKey(userId: userId.uuidString)
        if let cached: [Friend] = cache.get(cacheKey) {
            logSuccess("Cache hit for friends list")
            return cached
        }

        // Fetch all accepted friendships where user is either sender or receiver
        let friendships: [Friendship] = try await client
            .from("friendships")
            .select()
            .or("user_id.eq.\(userId.uuidString),friend_id.eq.\(userId.uuidString)")
            .eq("status", value: "accepted")
            .execute()
            .value

        print("ðŸ“Š [Friendship] Found \(friendships.count) friendships")

        // Extract friend user IDs
        let friendIds = friendships.map { friendship in
            friendship.userId == userId ? friendship.friendId : friendship.userId
        }

        guard !friendIds.isEmpty else {
            logSuccess("No friends found")
            cache.set(cacheKey, value: [], ttl: .friendsList)
            return []
        }

        // Fetch profiles with batched caching
        let profiles = try await fetchProfilesBatched(friendIds)

        logSuccess("Fetched \(profiles.count) friend profiles")

        // Combine friendships with profiles
        let friends = friendships.compactMap { friendship -> Friend? in
            let friendUserId = friendship.userId == userId ? friendship.friendId : friendship.userId
            guard let profile = profiles.first(where: { $0.id == friendUserId }) else {
                return nil
            }

            return Friend(
                id: profile.id,
                profile: profile,
                friendshipId: friendship.id,
                friendsSince: friendship.createdAt
            )
        }

        // Cache the result
        cache.set(cacheKey, value: friends, ttl: .friendsList)

        return friends
    }

    // MARK: - Fetch Pending Requests

    /// Fetch pending friend requests (both incoming and outgoing) with caching
    func fetchPendingRequests(userId: UUID) async throws -> (incoming: [FriendRequest], outgoing: [FriendRequest]) {
        print("ðŸ“¬ [Friendship] Fetching pending requests for user: \(userId)")

        // Try cache first
        let cacheKey = "friendRequests:\(userId.uuidString)"
        if let cached: (incoming: [FriendRequest], outgoing: [FriendRequest]) = cache.get(cacheKey) {
            logSuccess("Cache hit for friend requests")
            return cached
        }

        // Fetch all pending friendships
        let friendships: [Friendship] = try await client
            .from("friendships")
            .select()
            .or("user_id.eq.\(userId.uuidString),friend_id.eq.\(userId.uuidString)")
            .eq("status", value: "pending")
            .execute()
            .value

        print("ðŸ“Š [Friendship] Found \(friendships.count) pending requests")

        // Separate incoming and outgoing
        let incoming = friendships.filter { $0.friendId == userId }
        let outgoing = friendships.filter { $0.userId == userId }

        // Fetch profiles with batched caching
        let incomingUserIds = incoming.map { $0.userId }
        let incomingProfiles = try await fetchProfilesBatched(incomingUserIds)

        let outgoingUserIds = outgoing.map { $0.friendId }
        let outgoingProfiles = try await fetchProfilesBatched(outgoingUserIds)

        // Build FriendRequest objects
        let incomingRequests = incoming.compactMap { friendship -> FriendRequest? in
            guard let profile = incomingProfiles.first(where: { $0.id == friendship.userId }) else {
                return nil
            }
            return FriendRequest(
                id: friendship.id,
                friendship: friendship,
                profile: profile,
                isIncoming: true
            )
        }

        let outgoingRequests = outgoing.compactMap { friendship -> FriendRequest? in
            guard let profile = outgoingProfiles.first(where: { $0.id == friendship.friendId }) else {
                return nil
            }
            return FriendRequest(
                id: friendship.id,
                friendship: friendship,
                profile: profile,
                isIncoming: false
            )
        }

        let result = (incoming: incomingRequests, outgoing: outgoingRequests)

        // Cache the result
        cache.set(cacheKey, value: result, ttl: .friendsList)

        logSuccess("Incoming: \(incomingRequests.count), Outgoing: \(outgoingRequests.count)")
        return result
    }

    // MARK: - Check Friendship Status

    /// Check the friendship status between two users with caching
    func checkFriendshipStatus(userId: UUID, friendId: UUID) async throws -> Friendship? {
        // Try cache first
        let cacheKey = "friendshipStatus:\(userId.uuidString):\(friendId.uuidString)"
        if let cached: Friendship? = cache.get(cacheKey) {
            logSuccess("Cache hit for friendship status")
            return cached
        }

        let friendships: [Friendship] = try await client
            .from("friendships")
            .select()
            .or("and(user_id.eq.\(userId.uuidString),friend_id.eq.\(friendId.uuidString)),and(user_id.eq.\(friendId.uuidString),friend_id.eq.\(userId.uuidString))")
            .execute()
            .value

        let friendship = friendships.first

        // Cache the result
        cache.set(cacheKey, value: friendship, ttl: .friendsList)

        return friendship
    }

    // MARK: - Helper Methods

    /// Fetch multiple user profiles in a single batched query with individual caching
    private func fetchProfilesBatched(_ userIds: [UUID]) async throws -> [UserProfile] {
        guard !userIds.isEmpty else { return [] }

        // Check cache for each profile
        var profiles: [UserProfile] = []
        var uncachedIds: [UUID] = []

        for userId in userIds {
            let cacheKey = QueryCache.profileKey(userId: userId.uuidString)
            if let cached: UserProfile = cache.get(cacheKey) {
                profiles.append(cached)
            } else {
                uncachedIds.append(userId)
            }
        }

        // Fetch uncached profiles in a single batch query
        if !uncachedIds.isEmpty {
            let fetchedProfiles: [UserProfile] = try await client
                .from("profiles")
                .select()
                .in("id", values: uncachedIds.map { $0.uuidString })
                .execute()
                .value

            // Cache each fetched profile individually
            for profile in fetchedProfiles {
                let cacheKey = QueryCache.profileKey(userId: profile.id.uuidString)
                cache.set(cacheKey, value: profile, ttl: .userProfiles)
            }

            profiles.append(contentsOf: fetchedProfiles)
        }

        print("ðŸ’¾ [Friendship] Fetched \(profiles.count) profiles (\(profiles.count - uncachedIds.count) from cache)")
        return profiles
    }
}
