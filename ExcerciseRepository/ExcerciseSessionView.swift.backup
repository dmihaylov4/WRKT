//
//  ExerciseSessionView.swift
//  WRKT
//

import SwiftUI
import Foundation
import SVGView

#if canImport(UIKit)
private extension View {
    func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                        to: nil, from: nil, for: nil)
    }
}
#endif

// MARK: - Theme
private enum Theme {
    static let bg        = Color.black
    static let surface   = Color(red: 0.07, green: 0.07, blue: 0.07)
    static let surface2  = Color(red: 0.10, green: 0.10, blue: 0.10)
    static let border    = Color.white.opacity(0.10)
    static let text      = Color.white
    static let secondary = Color.white.opacity(0.65)
    static let accent    = Color(hex: "#F4E409")
}

// MARK: - Exercise session

struct ExerciseSessionView: View {
    @EnvironmentObject var store: WorkoutStoreV2

    let exercise: Exercise
    var currentEntryID: UUID? = nil

    @AppStorage("weight_unit") private var weightUnitRaw: String = WeightUnit.kg.rawValue
    private var unit: WeightUnit { WeightUnit(rawValue: weightUnitRaw) ?? .kg }

    @Environment(\.dismiss) private var dismiss

    @State private var sets: [SetInput] = [SetInput(reps: 10, weight: 0)]
    @State private var activeSetIndex: Int = 0  // Track which set is currently active
    @State private var didPreloadExisting = false
    @State private var showEmptyAlert = false
    var returnToHomeOnSave: Bool = false
    @State private var showInfo = false

    @EnvironmentObject var repo: ExerciseRepository
    @State private var showDemo = false

    private var totalReps: Int { sets.reduce(0) { $0 + max(0, $1.reps) } }
    private var workingSets: Int { sets.filter { $0.reps > 0 }.count }

    // Tutorial state
    @StateObject private var onboardingManager = OnboardingManager.shared
    @State private var showTutorial = false
    @State private var currentTutorialStep = 0
    @State private var setsSectionFrame: CGRect = .zero
    @State private var setTypeFrame: CGRect = .zero
    @State private var carouselsFrame: CGRect = .zero
    @State private var presetsFrame: CGRect = .zero
    @State private var addSetButtonFrame: CGRect = .zero
    @State private var infoButtonFrame: CGRect = .zero
    @State private var saveButtonFrame: CGRect = .zero
    @State private var framesReady = false

    // Debug: Set to true to visualize captured frames
    private let debugFrames = true

    // Offset to adjust frame positions
    @State private var yOffset: CGFloat = 0

    // Manual adjustment (increase this value to move frames UP)
    private let manualYAdjustment: CGFloat = 70

    
    //@EnvironmentObject var repo: ExerciseRepository
    // MARK: Body
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                VStack(spacing: 0) {
                    // New unified header
                    modernHeader

                    contentList
                    .listStyle(.plain)
                    .scrollContentBackground(.hidden)
                    .background(Theme.bg)
                    .scrollDismissesKeyboard(.immediately)
                    // Let child gestures fire first; this won't cancel button taps
                    .simultaneousGesture(TapGesture().onEnded { hideKeyboard() })
                    .simultaneousGesture(DragGesture().onChanged { _ in hideKeyboard() })
            }
            .safeAreaInset(edge: .bottom, spacing: 0) {
                VStack(spacing: 10) {
                    PrimaryCTA(title: saveButtonTitle) {
                        handleSave()
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 12)
                .background(Theme.bg)
                .overlay(Divider().background(Theme.border), alignment: .top)
                .captureFrame(in: .global) { frame in
                    saveButtonFrame = frame
                    print("üìç Save button frame captured: \(frame)")
                    checkFramesReady()
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .background(Theme.bg.ignoresSafeArea())
            .toolbarBackground(Theme.bg, for: .navigationBar)
            .toolbarBackground(.visible, for: .navigationBar)
            .alert("Empty workout", isPresented: $showEmptyAlert) {
                Button("OK", role: .cancel) { }
            } message: {
                Text("Add at least one set with reps to save.")
            }
            .onAppear {
                preloadExistingIfNeeded()

                print("üé¨ ExerciseSessionView appeared")
                // Reset for testing
                //OnboardingManager.shared.hasSeenExerciseSession = false

                // Calculate offset from geometry
                DispatchQueue.main.async {
                    yOffset = geometry.safeAreaInsets.top
                    print("üéØ Calculated Y offset: \(yOffset)")
                }

                // Fallback: if frames haven't loaded after 2.5 seconds, show tutorial anyway
                DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                    if !framesReady && !onboardingManager.hasSeenExerciseSession && !showTutorial {
                        print("‚ö†Ô∏è Frames not ready after 2.5s, showing tutorial without spotlights")
                        showTutorial = true
                    }
                }
            }
            .onChange(of: currentEntryID) { _ in preloadExistingIfNeeded(force: true) }
            .onChange(of: framesReady) { _, ready in
                // Show tutorial once frames are captured
                if ready && !onboardingManager.hasSeenExerciseSession && !showTutorial {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                        print("üéì Showing tutorial with frames:")
                        print("   Sets: \(setsSectionFrame)")
                        print("   Set type: \(setTypeFrame)")
                        print("   Carousels: \(carouselsFrame)")
                        print("   Presets: \(presetsFrame)")
                        print("   Add Set: \(addSetButtonFrame)")
                        print("   Info: \(infoButtonFrame)")
                        print("   Save: \(saveButtonFrame)")
                        showTutorial = true
                    }
                }
            }
            .onReceive(RestTimerManager.shared.$state) { state in
                // When rest timer completes, mark current set as completed and advance
                if case .completed(let exerciseID, _) = state,
                   exerciseID == exercise.id,
                   activeSetIndex < sets.count {
                    sets[activeSetIndex].isCompleted = true

                    // Check if this was the last set
                    let wasLastSet = (activeSetIndex == sets.count - 1)

                    if wasLastSet {
                        // Auto-generate a new set when completing the last one
                        generateNextSet()
                        activeSetIndex += 1
                    } else {
                        // Advance to existing next set
                        activeSetIndex += 1
                    }

                    // Persist the changes if editing existing entry
                    if let entryID = currentEntryID {
                        store.updateEntrySetsAndActiveIndex(entryID: entryID, sets: sets, activeSetIndex: activeSetIndex)
                    }
                }
            }

            // Tutorial overlay
            if showTutorial {
                SpotlightOverlay(
                    currentStep: tutorialSteps[currentTutorialStep],
                    currentIndex: currentTutorialStep,
                    totalSteps: tutorialSteps.count,
                    onNext: advanceTutorial,
                    onSkip: skipTutorial
                )
                .transition(.opacity)
                .zIndex(1000)
            }

      
            }
        }
    }
    
    // MARK: - Modern Header
    private var modernHeader: some View {
        VStack(spacing: 0) {
            // Rest timer banner (only shows when active for this exercise)
            RestTimerBanner(exerciseID: exercise.id)

            // Main exercise info
            VStack(spacing: 12) {
                // Exercise name and info button
                HStack(alignment: .center, spacing: 12) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(exercise.name)
                            .font(.title3.weight(.bold))
                            .foregroundStyle(Theme.text)
                            .lineLimit(2)

                        // Quick stats row
                        HStack(spacing: 12) {
                            StatBadge(icon: "list.bullet", value: "\(workingSets)", label: "sets")
                            StatBadge(icon: "repeat", value: "\(totalReps)", label: "reps")

                            if let e1rmKg = store.bestE1RM(exercise: exercise) {
                                let e1rmDisplay = unit == .kg ? e1rmKg : e1rmKg * 2.20462
                                StatBadge(
                                    icon: "star.fill",
                                    value: String(format: "%.0f", e1rmDisplay),
                                    label: "1RM \(unit.rawValue)",
                                    accent: true
                                )
                            }
                        }
                    }

                    Spacer()

                    // Info button
                    Button {
                        showInfo.toggle()
                    } label: {
                        Image(systemName: "info.circle.fill")
                            .font(.title2.weight(.semibold))
                            .foregroundStyle(Theme.secondary)
                            .frame(width: 44, height: 44)
                            .background(Theme.surface, in: Circle())
                            .overlay(Circle().stroke(Theme.border, lineWidth: 1))
                    }
                    .accessibilityLabel("Exercise info")
                    .captureFrame(in: .global) { frame in
                        infoButtonFrame = frame
                        print("üìç Info button frame captured: \(frame)")
                        checkFramesReady()
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 14)
            .background(Theme.bg)
        }
        .background(Theme.bg)
        .overlay(Divider().background(Theme.border), alignment: .bottom)
        .sheet(isPresented: $showInfo) {
            NavigationStack {
                ScrollView {
                    if let media = repo.media(for: exercise),
                       let s = media.youtube {
                        YouTubePlayerView(url: s)
                            .frame(height: 220)
                            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
                            .overlay(RoundedRectangle(cornerRadius: 12).stroke(Theme.border, lineWidth: 1))
                        if let videoURL = repo.media(for: exercise)?.youtube {
                            Link("Watch on YouTube", destination: videoURL)
                                .font(.caption)
                                .foregroundStyle(.blue)
                        }
                    }
                    VStack(spacing: 16) {
                        OverviewCard(meta: guideMeta)
                        RestTimerSettingsCard(exercise: exercise)
                        ExerciseMusclesSection(exercise: exercise, focus: .full)
                    }
                    .padding(16)
                    .background(Theme.bg.ignoresSafeArea())
                }
                .navigationTitle("Exercise Info")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .topBarTrailing) {
                        Button("Done") {
                            showInfo = false
                        }
                    }
                }
                .background(Theme.bg)
            }
            .presentationDetents([.medium, .large])
            .presentationDragIndicator(.visible)
        }
    }

    // MARK: - Stat Badge Component
    private struct StatBadge: View {
        let icon: String
        let value: String
        let label: String
        var accent: Bool = false

        var body: some View {
            HStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.caption2.weight(.semibold))
                    .foregroundStyle(accent ? Theme.accent : Theme.secondary)

                Text(value)
                    .font(.caption.monospacedDigit().weight(.bold))
                    .foregroundStyle(accent ? Theme.accent : Theme.text)

                Text(label)
                    .font(.caption2.weight(.medium))
                    .foregroundStyle(Theme.secondary)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(accent ? Theme.accent.opacity(0.1) : Theme.surface)
            .clipShape(Capsule())
            .overlay(Capsule().stroke(accent ? Theme.accent.opacity(0.3) : Theme.border, lineWidth: 1))
        }
    }

    @ViewBuilder
    private var contentList: some View {
        List {
  
            
            
            SetsSection(
                sets: $sets,
                activeSetIndex: $activeSetIndex,
                unit: unit,
                exercise: exercise,
                onDelete: { idx in
                    sets.remove(at: idx)
                    // Adjust activeSetIndex if needed
                    if activeSetIndex >= sets.count {
                        activeSetIndex = max(0, sets.count - 1)
                    }
                },
                onDuplicate: { idx in duplicateSet(at: idx) },
                onAdd: {
                    let last = sets.last ?? SetInput(reps: 10, weight: 0)
                    sets.append(SetInput(
                        reps: last.reps,
                        weight: last.weight,
                        tag: last.tag,                       // keep the type
                        autoWeight: last.autoWeight,         // keep auto state
                        didSeedFromMemory: false             // reset seed for a new row
                    ))
                },
                onSetsSectionFrameCaptured: { frame in
                    setsSectionFrame = frame
                    print("üìç Sets section frame captured: \(frame)")
                    checkFramesReady()
                },
                onSetTypeFrameCaptured: { frame in
                    setTypeFrame = frame
                    print("üìç Set type frame captured: \(frame)")
                    checkFramesReady()
                },
                onCarouselsFrameCaptured: { frame in
                    carouselsFrame = frame
                    print("üìç Carousels frame captured: \(frame)")
                    checkFramesReady()
                },
                onPresetsFrameCaptured: { frame in
                    presetsFrame = frame
                    print("üìç Presets frame captured: \(frame)")
                    checkFramesReady()
                },
                onAddSetButtonFrameCaptured: { frame in
                    addSetButtonFrame = frame
                    print("üìç Add Set button frame captured: \(frame)")
                    checkFramesReady()
                }
            )

          //  MusclesListSection(exercise: exercise)
        }
        .listStyle(.plain)
        .scrollContentBackground(.hidden)
        .background(Theme.bg)
        .scrollDismissesKeyboard(.interactively)
    }
    
    // MARK: Overview
    private struct OverviewSection: View {
        let meta: ExerciseGuideMeta
        var body: some View {
            Section {
                OverviewCard(meta: meta)
                    .listRowInsets(.init(top: 0, leading: 16, bottom: 12, trailing: 16))
                    .listRowBackground(Theme.bg)
                    .listRowSeparator(.hidden)
            }
        }
    }

    // MARK: Sets
    private struct SetsSection: View {
        @Binding var sets: [SetInput]
        @Binding var activeSetIndex: Int
        @EnvironmentObject private var store: WorkoutStoreV2

        let unit: WeightUnit
        let exercise: Exercise
        let onDelete: (Int) -> Void
        let onDuplicate: (Int) -> Void
        let onAdd: () -> Void

        // Tutorial frame capture callbacks
        var onSetsSectionFrameCaptured: ((CGRect) -> Void)? = nil
        var onSetTypeFrameCaptured: ((CGRect) -> Void)? = nil
        var onCarouselsFrameCaptured: ((CGRect) -> Void)? = nil
        var onPresetsFrameCaptured: ((CGRect) -> Void)? = nil
        var onAddSetButtonFrameCaptured: ((CGRect) -> Void)? = nil

        var body: some View {
            Section {
                HStack(spacing: 6) {
                    Image(systemName: "list.bullet")
                        .font(.caption2.weight(.semibold))
                        .foregroundStyle(Theme.secondary)

                    Text("Sets")
                        .font(.caption.weight(.semibold))
                        .foregroundStyle(Theme.secondary)
                        .textCase(.uppercase)

                    Spacer()

                    // Set counter badge
                    Text("\(sets.count)")
                        .font(.caption.monospacedDigit().weight(.semibold))
                        .foregroundStyle(Theme.accent)
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 8)
                .captureFrame(in: .global) { frame in
                    onSetsSectionFrameCaptured?(frame)
                }

                // Sets list
                ForEach(Array(sets.indices), id: \.self) { i in
                    let isActive = (i == activeSetIndex)
                    let isCompleted = sets[i].isCompleted
                    let isGhost = sets[i].isGhost && !isCompleted

                    SetRowUnified(
                        index: i + 1,
                        set: $sets[i],
                        unit: unit,
                        exercise: exercise,
                        isActive: isActive,
                        isGhost: isGhost,
                        onDuplicate: { onDuplicate(i) },
                        onActivate: {
                            // Tap to activate ghost set
                            activeSetIndex = i
                        },
                        onSetTypeFrameCaptured: i == 0 ? onSetTypeFrameCaptured : nil,
                        onCarouselsFrameCaptured: i == 0 ? onCarouselsFrameCaptured : nil
                    )
                    .listRowInsets(.init(top: 6, leading: 6, bottom: 6, trailing: 6))
                    .listRowSeparator(.hidden)
                    .listRowBackground(
                        isCompleted ? Theme.accent.opacity(0.05) :
                        isActive ? Theme.accent.opacity(0.03) :
                        Theme.surface
                    )
                    .swipeActions(edge: .trailing, allowsFullSwipe: false) {
                        Button("Delete", role: .destructive) { onDelete(i) }
                        Button("Duplicate") { onDuplicate(i) }
                    }
                }

                // Quick actions footer
                VStack(spacing: 10) {
                    // Quick preset buttons
                    HStack(spacing: 8) {
                        PresetButton(title: "Use Last", icon: "clock.arrow.circlepath") {
                            useLast()
                        }

                        PresetButton(title: "5√ó5", icon: "number.circle") {
                            applyFiveByFive()
                        }

                        if store.bestE1RM(exercise: exercise) != nil {
                            PresetButton(title: "Try 1RM", icon: "star.circle") {
                                tryOneRM()
                            }
                        }
                    }
                    .captureFrame(in: .global) { frame in
                        onPresetsFrameCaptured?(frame)
                    }

                    // Add set button
                    Button(action: onAdd) {
                        HStack(spacing: 8) {
                            Image(systemName: "plus.circle.fill")
                            Text("Add Set")
                                .fontWeight(.semibold)
                        }
                        .font(.subheadline)
                        .foregroundStyle(Theme.accent)
                        .frame(maxWidth: .infinity)
                        .frame(height: 44)
                        .background(Theme.accent.opacity(0.1))
                        .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12, style: .continuous)
                                .stroke(Theme.accent.opacity(0.3), lineWidth: 1)
                        )
                    }
                    .buttonStyle(.plain)
                    .captureFrame(in: .global) { frame in
                        onAddSetButtonFrameCaptured?(frame)
                    }
                }
                .listRowInsets(.init(top: 12, leading: 16, bottom: 8, trailing: 16))
                .listRowSeparator(.hidden)
                .listRowBackground(Theme.bg)
                
            }
        }

        private func useLast() {
            // Your existing useLast implementation
            if let lastWorkingSet = store.lastWorkingSet(exercise: exercise) {
                sets.append(SetInput(
                    reps: lastWorkingSet.reps,
                    weight: lastWorkingSet.weightKg,
                    tag: .working,
                    autoWeight: true,
                    didSeedFromMemory: true
                ))
            }
        }

        private func applyFiveByFive() {
            // Clear existing sets and add 5 working sets
            sets = (1...5).map { _ in
                SetInput(reps: 5, weight: 0, tag: .working, autoWeight: true)
            }
        }

        private func tryOneRM() {
            // Add a single set at calculated 1RM
            guard let e1rm = store.bestE1RM(exercise: exercise) else { return }
            sets.append(SetInput(
                reps: 1,
                weight: e1rm,
                tag: .working,
                autoWeight: false,  // Don't auto-adjust, this is the target
                didSeedFromMemory: false
            ))
            UIImpactFeedbackGenerator(style: .medium).impactOccurred()
        }
    }

    // Supporting view for preset buttons
    private struct PresetButton: View {
        let title: String
        let icon: String
        let action: () -> Void

        var body: some View {
            Button(action: action) {
                VStack(spacing: 4) {
                    Image(systemName: icon)
                        .font(.title3.weight(.medium))
                        .foregroundStyle(Theme.accent)
                    Text(title)
                        .font(.caption2.weight(.semibold))
                        .foregroundStyle(Theme.text)
                }
                .frame(minWidth: 60, maxWidth: .infinity)
                .frame(height: 60)
                .background(Theme.surface2)
                .clipShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
                .overlay(
                    RoundedRectangle(cornerRadius: 10, style: .continuous)
                        .stroke(Theme.border, lineWidth: 1)
                )
            }
            .buttonStyle(.plain)
        }
    }

    private struct PresetsRow: View {
        var onUseLast: () -> Void
        var onFiveByFive: () -> Void
        var body: some View {
            HStack(spacing: 8) {
                PresetChip(title: "Use last"); PresetChip(title: "5√ó5")
            }
            .onTapGesture { /* no-op */ }
        }
        private func PresetChip(title: String) -> some View {
            Text(title)
                .font(.system(size: 12, weight: .semibold))
                .foregroundStyle(.white.opacity(0.9))
                .padding(.horizontal, 12)
                .padding(.vertical, 7)
                .background(
                    ZStack {
                        Capsule()
                            .fill(Color(hex: "#1A1A1A"))

                        Capsule()
                            .fill(
                                LinearGradient(
                                    colors: [Theme.accent.opacity(0.15), Theme.accent.opacity(0.05)],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                    }
                )
                .overlay(
                    Capsule()
                        .stroke(
                            LinearGradient(
                                colors: [Theme.accent.opacity(0.4), Theme.accent.opacity(0.2)],
                                startPoint: .leading,
                                endPoint: .trailing
                            ),
                            lineWidth: 1
                        )
                )
        }
    }

    private struct SetRowCompactWrapper: View {
        @Binding var set: SetInput
        let index: Int
        let unit: WeightUnit
        let exercise: Exercise
        let onDelete: () -> Void
        let onDuplicate: () -> Void

        var body: some View {
            SetRowCompact(
                index: index,
                set: $set,                     // üëà pass the whole set
                unit: unit,
                exercise: exercise,
                onDuplicate: onDuplicate
            )
            .listRowInsets(.init(top: 0, leading: 0, bottom: 0, trailing: 0))
            .listRowSeparator(.hidden)
            .listRowBackground(Theme.surface)
            .swipeActions(edge: .trailing, allowsFullSwipe: false) {
                Button("Delete", role: .destructive, action: onDelete)
                Button("Duplicate", action: onDuplicate)
            }
        }
    }

    // MARK: Muscles section
    private struct MusclesListSection: View {
        let exercise: Exercise
        var body: some View {
            Section {
                ExerciseMusclesSection(exercise: exercise, focus: .full)
                    .listRowInsets(.init(top: 0, leading: 16, bottom: 12, trailing: 16))
                    .listRowSeparator(.hidden)
                    .listRowBackground(Theme.bg)
            } header: {
                Text("Muscles worked")
                    .foregroundStyle(Theme.secondary)
                    .padding(.horizontal, 16)
            }
        }
    }

    // MARK: Helpers
    private func cleaned(_ s: String?) -> String? {
        guard let t = s?.trimmingCharacters(in: .whitespacesAndNewlines),
              !t.isEmpty, t.lowercased() != "nan" else { return nil }
        return t
    }
    private func firstNonEmpty(_ values: String?...) -> String {
        for v in values { if let t = cleaned(v) { return t } }
        return ""
    }

    // Build the lightweight meta from your current Exercise model
    private var guideMeta: ExerciseGuideMeta {
        let difficulty = firstNonEmpty(exercise.level)
        let equipment  = firstNonEmpty(exercise.equipment, "Bodyweight")
        let classif    = firstNonEmpty(exercise.category)
        let mechanics  = firstNonEmpty(exercise.mechanic)
        let forceType  = firstNonEmpty(exercise.force)
        let grip       = firstNonEmpty(exercise.grip)    // optional on Exercise

        // Not stored in Exercise yet; leave empty so they‚Äôre filtered
        let pattern = "", plane = "", posture = "", laterality = ""

        var cues: [String] = []
        if mechanics.lowercased() == "isolation" { cues.append("Control the eccentric; avoid swinging.") }
        if mechanics.lowercased() == "compound"  { cues.append("Brace your core; keep ribs down.") }
        if forceType.lowercased() == "pull"      { cues.append("Initiate the pull without shrugging your shoulders.") }
        if !equipment.isEmpty && equipment.lowercased().contains("cable") {
            cues.append("Use a steady tempo (e.g., 3-1-1) to keep tension on the target muscle.")
        }
        if !grip.isEmpty { cues.append(gripCue(for: grip)) }

        return ExerciseGuideMeta(
            difficulty: difficulty,
            equipment: equipment,
            classification: classif,
            mechanics: mechanics,
            forceType: forceType,
            pattern: pattern,
            plane: plane,
            posture: posture,
            grip: grip,
            laterality: laterality,
            cues: cues
        )
    }

    private func gripCue(for grip: String) -> String {
        let g = grip.lowercased()
        switch true {
        case g.contains("pronated"):
            return "Pronated grip: palms away‚Äîkeep wrists straight and elbows ~45¬∞."
        case g.contains("supinated"):
            return "Supinated grip: palms toward you‚Äîtuck elbows; avoid wrist extension."
        case g.contains("neutral"):
            return "Neutral grip: palms facing‚Äîstack wrists under forearms and don‚Äôt flare."
        case g.contains("mixed"):
            return "Mixed grip: rotate sides between sets and keep both wrists neutral."
        case g.contains("hook"):
            return "Hook grip: thumb under fingers‚Äîkeep wrist straight to reduce strain."
        default:
            return "Use a \(grip) grip and keep wrists neutral‚Äînot bent back."
        }
    }

    // MARK: Actions
    private func duplicateSet(at index: Int) {
        guard sets.indices.contains(index) else { return }
        let s = sets[index]
        sets.append(s) // preserves tag/auto/didSeed
        UIImpactFeedbackGenerator(style: .light).impactOccurred()
    }

    private func generateNextSet() {
        // Generate a new set based on the last completed set
        if let lastSet = sets.last {
            let newSet = SetInput(
                reps: lastSet.reps,
                weight: lastSet.weight,
                tag: lastSet.tag,
                autoWeight: false,
                didSeedFromMemory: false,
                isCompleted: false,
                isGhost: false
            )
            sets.append(newSet)
        } else {
            // Fallback: create a default set
            sets.append(SetInput(reps: 10, weight: 0, tag: .working, autoWeight: true))
        }
        UIImpactFeedbackGenerator(style: .light).impactOccurred()
    }

    private func preloadExistingIfNeeded(force: Bool = false) {
        guard let id = currentEntryID else { return }
        guard force || !didPreloadExisting else { return }
        if let entry = store.currentWorkout?.entries.first(where: { $0.id == id }),
           !entry.sets.isEmpty {
            sets = entry.sets
            activeSetIndex = entry.activeSetIndex
        }
        didPreloadExisting = true
    }

    private func cleanSets() -> [SetInput] {
        sets.map {
            var s = $0
            s.reps = max(0, s.reps)
            s.weight = max(0, s.weight)
            return s
        }
    }

    // MARK: - Tutorial Logic

    private func checkFramesReady() {
        // Check if all frames have been captured and are valid
        let setsReady = setsSectionFrame != .zero && setsSectionFrame.height > 0
        let setTypeReady = setTypeFrame != .zero && setTypeFrame.width > 0
        let carouselsReady = carouselsFrame != .zero && carouselsFrame.width > 0
        let presetsReady = presetsFrame != .zero && presetsFrame.width > 0
        let addSetReady = addSetButtonFrame != .zero && addSetButtonFrame.width > 0
        let infoReady = infoButtonFrame != .zero && infoButtonFrame.width > 0
        let saveReady = saveButtonFrame != .zero && saveButtonFrame.width > 0

        print("üîç Frame readiness check:")
        print("   Sets section: \(setsReady) - \(setsSectionFrame)")
        print("   Set type: \(setTypeReady) - \(setTypeFrame)")
        print("   Carousels: \(carouselsReady) - \(carouselsFrame)")
        print("   Presets: \(presetsReady) - \(presetsFrame)")
        print("   Add Set: \(addSetReady) - \(addSetButtonFrame)")
        print("   Info: \(infoReady) - \(infoButtonFrame)")
        print("   Save: \(saveReady) - \(saveButtonFrame)")

        if setsReady && setTypeReady && carouselsReady && presetsReady && addSetReady && infoReady && saveReady && !framesReady {
            print("‚úÖ All frames ready for tutorial!")
            framesReady = true
        } else if !framesReady {
            print("‚è≥ Still waiting for frames...")
        }
    }

    private var tutorialSteps: [TutorialStep] {
        // Helper to adjust frame for offset
        let totalOffset = yOffset + manualYAdjustment

        func adjustFrame(_ frame: CGRect) -> CGRect {
            CGRect(
                x: frame.origin.x,
                y: frame.origin.y - totalOffset,
                width: frame.width,
                height: frame.height
            )
        }

        return [
            TutorialStep(
                title: "Sets Section",
                message: "This is where you track your sets. Each row represents one set with reps and weight.",
                spotlightFrame: adjustFrame(setsSectionFrame).insetBy(dx: -8, dy: -8),
                tooltipPosition: .bottom,
                highlightCornerRadius: 16
            ),
            TutorialStep(
                title: "Set Type",
                message: "Tap the colored dot to cycle through set types: Working, Warmup, Drop set, or Failure set.",
                spotlightFrame: adjustFrame(setTypeFrame).insetBy(dx: -8, dy: -8),
                tooltipPosition: .bottom,
                highlightCornerRadius: 12
            ),
            TutorialStep(
                title: "Reps & Weight",
                message: "Use the scroll wheels to adjust reps and weight. Swipe up or down to change values quickly.",
                spotlightFrame: adjustFrame(carouselsFrame).insetBy(dx: -8, dy: -8),
                tooltipPosition: .bottom,
                highlightCornerRadius: 14
            ),
            TutorialStep(
                title: "Quick Presets",
                message: "Use Last copies your previous workout. 5√ó5 creates five sets of five reps. Try 1RM appears when you have a personal record and suggests a weight for a single rep max attempt.",
                spotlightFrame: adjustFrame(presetsFrame).insetBy(dx: -8, dy: -8),
                tooltipPosition: .bottom,
                highlightCornerRadius: 12
            ),
            TutorialStep(
                title: "Add Set",
                message: "Tap here to add more sets to your workout. New sets copy the values from your last set.",
                spotlightFrame: adjustFrame(addSetButtonFrame).insetBy(dx: -8, dy: -8),
                tooltipPosition: .bottom,
                highlightCornerRadius: 14
            ),
            TutorialStep(
                title: "Exercise Info",
                message: "Tap the info button to see exercise details, watch tutorial videos, and adjust rest timer settings.",
                spotlightFrame: adjustFrame(infoButtonFrame).insetBy(dx: -8, dy: -8),
                tooltipPosition: .bottom,
                highlightCornerRadius: 24
            ),
            TutorialStep(
                title: "Save Workout",
                message: "When you're done, tap here to save all your sets to your current workout session.",
                spotlightFrame: adjustFrame(saveButtonFrame).insetBy(dx: -8, dy: -8),
                tooltipPosition: .bottom,
                highlightCornerRadius: 16
            )
        ]
    }

    private func advanceTutorial() {
        if currentTutorialStep < tutorialSteps.count - 1 {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                currentTutorialStep += 1
            }
        } else {
            completeTutorial()
        }
    }

    private func skipTutorial() {
        completeTutorial()
    }

    private func completeTutorial() {
        withAnimation(.easeOut(duration: 0.2)) {
            showTutorial = false
        }
        onboardingManager.complete(.exerciseSession)
    }

    // ExerciseSessionView.swift

    // MARK: - Save Button Logic

    private var saveButtonTitle: String {
        if currentEntryID == nil {
            return "Save to Current Workout"
        }

        // Check if active set is a ghost set
        if activeSetIndex < sets.count && sets[activeSetIndex].isGhost {
            return "Log Set \(activeSetIndex + 1)"
        }

        // Check if all sets are completed
        let allCompleted = sets.allSatisfy { $0.isCompleted || $0.isGhost }
        if allCompleted {
            return "Update Workout"
        }

        return "Log Set \(activeSetIndex + 1)"
    }

    private func handleSave() {
        // Convert ghost to real set if needed
        if activeSetIndex < sets.count && sets[activeSetIndex].isGhost {
            sets[activeSetIndex].isGhost = false
        }

        // Save the workout
        if currentEntryID == nil {
            saveAsNewEntry()
        } else {
            saveToCurrentWithoutDismiss()
        }

        // Start rest timer for the exercise
        // When timer ends, it will mark set as completed and advance
        startRestTimerIfEnabled()
    }

    private func saveAsNewEntry() {
        let clean = cleanSets()

        // Prevent saving if no valid sets
        guard clean.contains(where: { $0.reps > 0 || $0.weight > 0 }) else {
            showEmptyAlert = true
            return
        }

        let entryID = store.addExerciseToCurrent(exercise)
        store.updateEntrySets(entryID: entryID, sets: clean)

        UINotificationFeedbackGenerator().notificationOccurred(.success)

        dismiss()

        if returnToHomeOnSave {
            NotificationCenter.default.post(name: .dismissLiveOverlay, object: nil)
            AppBus.postResetHome(reason: .user_intent)
        } else {
            // When saving from overlay, collapse it
            NotificationCenter.default.post(name: .dismissLiveOverlay, object: nil)
        }
    }

    private func saveToCurrentWithoutDismiss() {
        guard let entryID = currentEntryID else { return }
        let clean = cleanSets()

        // Prevent saving if no valid sets
        guard clean.contains(where: { $0.reps > 0 || $0.weight > 0 }) else {
            showEmptyAlert = true
            return
        }

        store.updateEntrySetsAndActiveIndex(entryID: entryID, sets: clean, activeSetIndex: activeSetIndex)
        UINotificationFeedbackGenerator().notificationOccurred(.success)
    }

    private func saveToCurrent() {
        guard let entryID = currentEntryID else { return }
        let clean = cleanSets()

        // Prevent saving if no valid sets
        guard clean.contains(where: { $0.reps > 0 || $0.weight > 0 }) else {
            showEmptyAlert = true
            return
        }

        store.updateEntrySets(entryID: entryID, sets: clean)
        UINotificationFeedbackGenerator().notificationOccurred(.success)

        dismiss()

        if returnToHomeOnSave {
            NotificationCenter.default.post(name: .dismissLiveOverlay, object: nil)
            AppBus.postResetHome(reason: .user_intent)
        } else {
            // When saving from overlay, collapse it
            NotificationCenter.default.post(name: .dismissLiveOverlay, object: nil)
        }
    }

    // MARK: - Rest Timer Support

    private func startRestTimerIfEnabled() {
        let prefs = RestTimerPreferences.shared
        guard prefs.isEnabled else { return }

        let manager = RestTimerManager.shared

        // If timer is already running for this exercise, preserve the adjusted time
        if manager.isTimerFor(exerciseID: exercise.id) && manager.isRunning {
            let adjustedDuration = manager.remainingSeconds
            // Restart with the current adjusted time
            manager.startTimer(duration: adjustedDuration, exerciseID: exercise.id, exerciseName: exercise.name)
        } else {
            // Start fresh with default duration
            let duration = prefs.restDuration(for: exercise)
            manager.startTimer(duration: duration, exerciseID: exercise.id, exerciseName: exercise.name)
        }
    }
}

// MARK: - Overview card (chips + tips)

private struct ExerciseGuideMeta: Hashable {
    let difficulty: String
    let equipment: String
    let classification: String
    let mechanics: String
    let forceType: String
    let pattern: String
    let plane: String
    let posture: String
    let grip: String
    let laterality: String
    let cues: [String]
}

private struct OverviewCard: View {
    let meta: ExerciseGuideMeta
    @State private var showAllTips = false

    var chips: [ChipItem] {
        var c: [ChipItem] = []
        if !meta.difficulty.isEmpty   { c.append(.init(icon: "dial.medium.fill", label: meta.difficulty)) }
        if !meta.equipment.isEmpty    { c.append(.init(icon: "dumbbell.fill",    label: meta.equipment)) }
        if !meta.mechanics.isEmpty    { c.append(.init(icon: "gearshape",        label: meta.mechanics)) }
        if !meta.forceType.isEmpty    { c.append(.init(icon: "arrow.left.arrow.right", label: meta.forceType)) }
        if !meta.grip.isEmpty         { c.append(.init(icon: "hand.raised.fill", label: meta.grip)) }
        if !meta.classification.isEmpty { c.append(.init(icon: "tag.fill",       label: meta.classification)) }
        return c
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Chips (horizontal, premium)
            if !chips.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 8) {
                        ForEach(chips) { ChipView(item: $0) }
                    }
                    .padding(.horizontal, 12)
                    .padding(.vertical, 10)
                }
                .background(
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .fill(
                            LinearGradient(
                                colors: [Color(hex: "#0D0D0D"), Color(hex: "#1A1A1A")],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: 16, style: .continuous)
                                .stroke(.white.opacity(0.08), lineWidth: 1)
                        )
                )
                .padding(.top, 2)
                .padding(.bottom, 2)
                .padding(.horizontal, 0)
            }

            // Technique tips
            if !meta.cues.isEmpty {
                Text("Technique tips")
                    .font(.subheadline.weight(.semibold))
                    .foregroundStyle(Theme.secondary)

                let tips = Array(meta.cues.prefix(showAllTips ? meta.cues.count : 3))
                VStack(alignment: .leading, spacing: 8) {
                    ForEach(tips, id: \.self) { cue in
                        HStack(alignment: .firstTextBaseline, spacing: 8) {
                            Image(systemName: "lightbulb")
                                .font(.caption2.weight(.bold))
                                .foregroundStyle(Theme.accent)
                                .frame(width: 16)
                            Text(cue)
                                .foregroundStyle(.white.opacity(0.92))
                                .font(.footnote)
                                .fixedSize(horizontal: false, vertical: true)
                        }
                    }

                    if meta.cues.count > 3 {
                        Button(showAllTips ? "Show less" : "Show more") {
                            withAnimation(.easeInOut(duration: 0.18)) { showAllTips.toggle() }
                        }
                        .font(.caption.weight(.semibold))
                        .foregroundStyle(Theme.accent)
                        .frame(maxWidth: .infinity, alignment: .trailing)
                        .padding(.top, 2)
                    }
                }
                .padding(12)
                .background(Theme.surface)
                .overlay(RoundedRectangle(cornerRadius: 12).stroke(Theme.border, lineWidth: 1))
                .clipShape(RoundedRectangle(cornerRadius: 12))
            }
        }
    }

    struct ChipItem: Identifiable, Hashable {
        let id = UUID()
        let icon: String
        let label: String

        var color: Color {
            // Smart color mapping based on content
            switch label.lowercased() {
            // Equipment
            case let s where s.contains("dumbbell"): return .blue
            case let s where s.contains("barbell"): return .blue
            case let s where s.contains("cable"): return .cyan
            case let s where s.contains("machine"): return .purple
            case let s where s.contains("band"): return .pink
            case let s where s.contains("bodyweight"): return .green

            // Force/Movement
            case let s where s.contains("push"): return .orange
            case let s where s.contains("pull"): return .green
            case let s where s.contains("static"): return .purple

            // Mechanics
            case let s where s.contains("compound"): return .orange
            case let s where s.contains("isolation"): return .cyan

            // Difficulty
            case let s where s.contains("beginner"): return .green
            case let s where s.contains("intermediate"): return .yellow
            case let s where s.contains("advanced"): return .orange
            case let s where s.contains("expert"): return .red

            default: return Theme.accent
            }
        }
    }

    private struct ChipView: View {
        let item: ChipItem

        var body: some View {
            HStack(spacing: 7) {
                Image(systemName: item.icon)
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundStyle(item.color)

                Text(item.label)
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundStyle(.white.opacity(0.9))
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 7)
            .background(
                ZStack {
                    // Base dark background
                    Capsule()
                        .fill(Color(hex: "#1A1A1A"))

                    // Subtle color glow
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [item.color.opacity(0.15), item.color.opacity(0.05)],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                }
            )
            .overlay(
                Capsule()
                    .stroke(
                        LinearGradient(
                            colors: [item.color.opacity(0.4), item.color.opacity(0.2)],
                            startPoint: .leading,
                            endPoint: .trailing
                        ),
                        lineWidth: 1
                    )
            )
        }
    }
}

// MARK: - Rest Timer Settings Card

private struct RestTimerSettingsCard: View {
    let exercise: Exercise
    @ObservedObject private var prefs = RestTimerPreferences.shared

    private var currentDuration: TimeInterval {
        // Force view update by reading lastUpdate
        _ = prefs.lastUpdate
        return prefs.restDuration(for: exercise)
    }

    private var hasCustomTimer: Bool {
        prefs.hasOverride(for: exercise.id)
    }

    private var durationSource: String {
        if hasCustomTimer {
            return "Custom"
        } else if exercise.mechanic?.lowercased() == "compound" {
            return "Compound Default"
        } else {
            return "Isolation Default"
        }
    }

    private var timeString: String {
        let minutes = Int(currentDuration) / 60
        let seconds = Int(currentDuration) % 60
        if seconds == 0 {
            return "\(minutes):00"
        } else {
            return String(format: "%d:%02d", minutes, seconds)
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header
            HStack {
                Image(systemName: "hourglass")
                    .font(.caption.weight(.semibold))
                    .foregroundStyle(Theme.accent)
                Text("Rest Timer")
                    .font(.subheadline.weight(.semibold))
                    .foregroundStyle(Theme.text)
            }

            // Current timer display
            NavigationLink {
                CustomTimerEditorView(exercise: exercise)
            } label: {
                HStack(spacing: 12) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(timeString)
                            .font(.title2.monospacedDigit().weight(.bold))
                            .foregroundStyle(Theme.text)

                        HStack(spacing: 4) {
                            if hasCustomTimer {
                                Image(systemName: "star.fill")
                                    .font(.caption2)
                                    .foregroundStyle(Theme.accent)
                            }
                            Text(durationSource)
                                .font(.caption)
                                .foregroundStyle(Theme.secondary)
                        }
                    }

                    Spacer()

                    // Edit indicator
                    Image(systemName: "chevron.right")
                        .font(.caption.weight(.semibold))
                        .foregroundStyle(Theme.secondary)
                }
                .padding(12)
                .background(Theme.surface)
                .overlay(RoundedRectangle(cornerRadius: 12).stroke(Theme.border, lineWidth: 1))
                .clipShape(RoundedRectangle(cornerRadius: 12))
            }
            .buttonStyle(.plain)
        }
    }
}

// MARK: - Custom Timer Editor View

private struct CustomTimerEditorView: View {
    let exercise: Exercise
    @ObservedObject private var prefs = RestTimerPreferences.shared
    @Environment(\.dismiss) private var dismiss

    @State private var minutes: Int = 0
    @State private var seconds: Int = 0

    private var hasCustomTimer: Bool {
        prefs.hasOverride(for: exercise.id)
    }

    var body: some View {
        VStack(spacing: 24) {
            // Timer preview
            VStack(spacing: 8) {
                Text("Rest Timer")
                    .font(.caption.weight(.semibold))
                    .foregroundStyle(Theme.secondary)
                    .textCase(.uppercase)

                Text(String(format: "%d:%02d", minutes, seconds))
                    .font(.system(size: 48, weight: .bold, design: .rounded))
                    .monospacedDigit()
                    .foregroundStyle(Theme.accent)
            }
            .padding(.top, 32)

            // Pickers
            VStack(spacing: 16) {
                HStack {
                    Text("Minutes")
                        .font(.subheadline.weight(.semibold))
                        .foregroundStyle(Theme.text)
                    Spacer()
                    Picker("Minutes", selection: $minutes) {
                        ForEach(0..<11) { m in
                            Text("\(m)").tag(m)
                        }
                    }
                    .pickerStyle(.wheel)
                    .frame(width: 100, height: 120)
                }

                HStack {
                    Text("Seconds")
                        .font(.subheadline.weight(.semibold))
                        .foregroundStyle(Theme.text)
                    Spacer()
                    Picker("Seconds", selection: $seconds) {
                        ForEach(Array(stride(from: 0, to: 60, by: 15)), id: \.self) { s in
                            Text("\(s)").tag(s)
                        }
                    }
                    .pickerStyle(.wheel)
                    .frame(width: 100, height: 120)
                }
            }
            .padding(.horizontal, 24)

            Spacer()

            // Reset button (if custom timer exists)
            if hasCustomTimer {
                Button {
                    prefs.removeOverride(for: exercise.id)
                    UINotificationFeedbackGenerator().notificationOccurred(.success)
                    dismiss()
                } label: {
                    HStack(spacing: 8) {
                        Image(systemName: "arrow.counterclockwise")
                        Text("Reset to Default")
                    }
                    .font(.subheadline.weight(.semibold))
                    .foregroundStyle(Theme.secondary)
                    .frame(maxWidth: .infinity)
                    .frame(height: 44)
                    .background(Theme.surface)
         
                    .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .stroke(Theme.border, lineWidth: 1)
                    )
                }
                .buttonStyle(.plain)
                .padding(.horizontal, 24)
                .padding(.bottom, 16)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Theme.bg)
        .navigationTitle("Custom Rest Timer")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .confirmationAction) {
                Button("Save") {
                    let totalSeconds = minutes * 60 + seconds
                    prefs.setRestDuration(totalSeconds, for: exercise.id)
                    UINotificationFeedbackGenerator().notificationOccurred(.success)
                    dismiss()
                }
                .fontWeight(.semibold)
                .disabled(minutes == 0 && seconds == 0)
            }
        }
        .onAppear {
            // Initialize with current duration
            let currentDuration = Int(prefs.restDuration(for: exercise))
            minutes = currentDuration / 60
            seconds = currentDuration % 60
        }
    }
}

// MARK: - Sets row (unchanged UX)



private struct TagDotCycler: View {
    @Binding var tag: SetTag
    var body: some View {
        Button {
            cycle()
        } label: {
            HStack(spacing: 6) {
                Circle().fill(tag.color).frame(width: 10, height: 10)
                Text(tag.short)
                    .font(.caption2.weight(.semibold))
                    .foregroundStyle(Theme.text)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 5)
            .background(Theme.surface2, in: Capsule())
            .overlay(Capsule().stroke(Theme.border, lineWidth: 0.75))
        }
        .buttonStyle(.plain) // ‚úÖ important
        .contextMenu {
            ForEach(SetTag.allCases, id: \.self) { t in Button(t.label) { tag = t } }
        }
        .accessibilityLabel("Set type \(tag.label)")
    }

    private func cycle() {
        let all = SetTag.allCases
        if let idx = all.firstIndex(of: tag) {
            let next = all.index(after: idx)
            tag = next < all.endIndex ? all[next] : all.first!
        } else { tag = .working }
        UIImpactFeedbackGenerator(style: .light).impactOccurred()
    }
}

// MARK: - Scroll Wheel Setters
private struct CarouselStepperInt: View {
    @Binding var value: Int
    let range: ClosedRange<Int>
    let step: Int
    let label: String
    var onChange: () -> Void = {}

    @State private var selection: Int? = nil
    @State private var isEditing = false
    @State private var isScrolling = false
    @State private var debounceTask: Task<Void, Never>?
    @FocusState private var isFocused: Bool

    private var values: [Int] {
        stride(from: range.lowerBound, through: range.upperBound, by: step).map { $0 }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(label)
                .font(.caption2.weight(.semibold))
                .foregroundStyle(Theme.secondary)
                .textCase(.uppercase)

            ZStack {
                // Background container for better visibility
                RoundedRectangle(cornerRadius: 8, style: .continuous)
                    .fill(Theme.surface.opacity(0.5))
                    .overlay(
                        RoundedRectangle(cornerRadius: 8, style: .continuous)
                            .stroke(Theme.border, lineWidth: 1)
                    )
                    .frame(height: 40)

                // Scroll wheel (hidden when editing)
                if !isEditing {
                    ScrollViewReader { proxy in
                        ScrollView(.horizontal, showsIndicators: false) {
                            LazyHStack(spacing: 4) {
                                ForEach(values, id: \.self) { v in
                                    Text("\(v)")
                                        .font(.callout.monospacedDigit().weight(v == value ? .bold : .regular))
                                        .foregroundStyle(v == value ? Theme.accent : Theme.secondary)
                                        .frame(width: 44, height: 36)
                                        .background {
                                            if v == value {
                                                RoundedRectangle(cornerRadius: 6, style: .continuous)
                                                    .fill(Theme.surface2)
                                                    .overlay(
                                                        RoundedRectangle(cornerRadius: 6, style: .continuous)
                                                            .stroke(Theme.accent.opacity(0.5), lineWidth: 1.5)
                                                    )
                                            }
                                        }
                                        .contentShape(Rectangle())
                                        .onTapGesture {
                                            if v == value {
                                                isEditing = true
                                                isFocused = true
                                            } else {
                                                withAnimation(.easeOut(duration: 0.2)) {
                                                    value = v
                                                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                                                    onChange()
                                                }
                                            }
                                        }
                                        .id(v)
                                }
                            }
                            .scrollTargetLayout()
                        }
                        .scrollTargetBehavior(.viewAligned)
                        .scrollIndicators(.never)
                        .scrollPosition(id: $selection, anchor: .center)
                        .frame(height: 40)
                        .onChange(of: selection) { _, newSelection in
                            // Debounce value updates during fast scrolling
                            guard let newSelection = newSelection, newSelection != value else { return }

                            debounceTask?.cancel()
                            debounceTask = Task {
                                try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
                                guard !Task.isCancelled else { return }

                                if newSelection != value {
                                    value = newSelection
                                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                                    onChange()
                                }
                            }
                        }
                        .onChange(of: value) { _, new in
                            // Cancel debounce if value changes programmatically
                            debounceTask?.cancel()
                            withAnimation(.easeOut(duration: 0.2)) {
                                proxy.scrollTo(new, anchor: .center)
                            }
                            selection = new
                        }
                        .onAppear {
                            if !values.contains(value) {
                                value = values.first ?? range.lowerBound
                            }
                            selection = value
                            proxy.scrollTo(value, anchor: .center)
                        }
                    }
                }

                // Manual input (shown when editing)
                if isEditing {
                    TextField("", value: $value, format: .number)
                        .keyboardType(.numberPad)
                        .focused($isFocused)
                        .multilineTextAlignment(.center)
                        .font(.headline.monospacedDigit().weight(.bold))
                        .foregroundStyle(Theme.accent)
                        .frame(height: 40)
                        .background(Theme.surface2)
                        .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
                        .overlay(
                            RoundedRectangle(cornerRadius: 8, style: .continuous)
                                .stroke(Theme.accent, lineWidth: 2)
                        )
                        .onChange(of: value) { _, _ in
                            onChange()
                        }
                }
            }
            .onChange(of: isFocused) { _, focused in
                if !focused {
                    isEditing = false
                }
            }
        }
        .toolbar {
            if isFocused {
                ToolbarItemGroup(placement: .keyboard) {
                    Spacer()
                    Button("Done") {
                        isFocused = false
                        isEditing = false
                    }
                }
            }
        }
    }
}

private struct CarouselStepperDouble: View {
    @Binding var value: Double
    let lowerBound: Double
    let upperBound: Double
    let step: Double
    let label: String
    var suffix: String = ""
    var onManual: () -> Void = {}

    @State private var selection: Double? = nil
    @State private var isEditing = false
    @State private var debounceTask: Task<Void, Never>?
    @State private var isUpdatingFromScroll = false
    @FocusState private var isFocused: Bool

    private var values: [Double] {
        var arr: [Double] = []
        var cur = lowerBound
        while cur <= upperBound + 1e-9 {
            let snapped = (cur / step).rounded() * step
            arr.append(snapped)
            cur += step
        }
        return Array(Set(arr)).sorted()
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack(spacing: 4) {
                Text(label)
                    .font(.caption2.weight(.semibold))
                    .foregroundStyle(Theme.secondary)
                    .textCase(.uppercase)

                if !suffix.isEmpty {
                    Text("(\(suffix))")
                        .font(.caption2.weight(.medium))
                        .foregroundStyle(Theme.secondary.opacity(0.7))
                }
            }

            ZStack {
                // Background container for better visibility
                RoundedRectangle(cornerRadius: 8, style: .continuous)
                    .fill(Theme.surface.opacity(0.5))
                    .overlay(
                        RoundedRectangle(cornerRadius: 8, style: .continuous)
                            .stroke(Theme.border, lineWidth: 1)
                    )
                    .frame(height: 40)

                // Scroll wheel (hidden when editing)
                if !isEditing {
                    ScrollViewReader { proxy in
                        ScrollView(.horizontal, showsIndicators: false) {
                            LazyHStack(spacing: 4) {
                                ForEach(values, id: \.self) { v in
                                    Text("\(formatValue(v))")
                                        .font(.callout.monospacedDigit().weight(abs(v - value) < 0.01 ? .bold : .regular))
                                        .foregroundStyle(abs(v - value) < 0.01 ? Theme.accent : Theme.secondary)
                                        .frame(width: 52, height: 36)
                                        .background {
                                            if abs(v - value) < 0.01 {
                                                RoundedRectangle(cornerRadius: 6, style: .continuous)
                                                    .fill(Theme.surface2)
                                                    .overlay(
                                                        RoundedRectangle(cornerRadius: 6, style: .continuous)
                                                            .stroke(Theme.accent.opacity(0.5), lineWidth: 1.5)
                                                    )
                                            }
                                        }
                                        .contentShape(Rectangle())
                                        .onTapGesture {
                                            if abs(v - value) < 0.01 {
                                                isEditing = true
                                                isFocused = true
                                            } else {
                                                withAnimation(.easeOut(duration: 0.2)) {
                                                    value = v
                                                    onManual()
                                                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                                                }
                                            }
                                        }
                                        .id(v)
                                }
                            }
                            .scrollTargetLayout()
                        }
                        .scrollTargetBehavior(.viewAligned)
                        .scrollIndicators(.never)
                        .scrollPosition(id: $selection, anchor: .center)
                        .frame(height: 40)
                        .onChange(of: selection) { _, newSelection in
                            // Debounce value updates during fast scrolling
                            guard let newSelection = newSelection, abs(newSelection - value) > 0.01 else { return }

                            debounceTask?.cancel()
                            debounceTask = Task {
                                try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
                                guard !Task.isCancelled else { return }

                                if abs(newSelection - value) > 0.01 {
                                    isUpdatingFromScroll = true
                                    // Ensure we use a value that exists in the array
                                    value = closestValue(newSelection)
                                    isUpdatingFromScroll = false
                                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                                    onManual()
                                }
                            }
                        }
                        .onChange(of: value) { _, new in
                            // Skip if this value change came from scrolling
                            guard !isUpdatingFromScroll else { return }

                            // Cancel debounce if value changes programmatically
                            debounceTask?.cancel()
                            let snapped = closestValue(new)
                            withAnimation(.easeOut(duration: 0.2)) {
                                proxy.scrollTo(snapped, anchor: .center)
                            }
                            selection = snapped
                        }
                        .onAppear {
                            let snapped = closestValue(value)
                            selection = snapped
                            proxy.scrollTo(snapped, anchor: .center)
                        }
                    }
                }

                // Manual input (shown when editing)
                if isEditing {
                    TextField("", value: $value, format: .number.precision(.fractionLength(0...1)))
                        .keyboardType(.decimalPad)
                        .focused($isFocused)
                        .multilineTextAlignment(.center)
                        .font(.headline.monospacedDigit().weight(.bold))
                        .foregroundStyle(Theme.accent)
                        .frame(height: 40)
                        .background(Theme.surface2)
                        .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
                        .overlay(
                            RoundedRectangle(cornerRadius: 8, style: .continuous)
                                .stroke(Theme.accent, lineWidth: 2)
                        )
                        .onChange(of: value) { _, _ in
                            onManual()
                        }
                }
            }
            .onChange(of: isFocused) { _, focused in
                if !focused {
                    isEditing = false
                    // Snap to nearest step value when done editing
                    let snapped = closestValue(value)
                    if abs(value - snapped) > 0.01 {
                        value = snapped
                        selection = snapped
                        onManual()
                    }
                }
            }
        }
        .toolbar {
            if isFocused {
                ToolbarItemGroup(placement: .keyboard) {
                    Spacer()
                    Button("Done") {
                        isFocused = false
                        isEditing = false
                    }
                }
            }
        }
    }

    private func snap(_ v: Double) -> Double {
        let clamped = min(max(v, lowerBound), upperBound)
        return (clamped / step).rounded() * step
    }

    // Find the closest value that actually exists in the values array
    private func closestValue(_ v: Double) -> Double {
        guard !values.isEmpty else { return lowerBound }
        return values.min(by: { abs($0 - v) < abs($1 - v) }) ?? v
    }

    private func formatValue(_ v: Double) -> String {
        if v.truncatingRemainder(dividingBy: 1) == 0 {
            return String(format: "%.0f", v)
        } else {
            return String(format: "%.1f", v)
        }
    }
}


// MARK: - Capsule Steppers (compact alternative - not currently used)

private struct CapsuleStepperInt: View {
    let title: String
    @Binding var value: Int
    let range: ClosedRange<Int>
    var onChange: () -> Void = {}

    // tuning
    private let hPad: CGFloat = 6
    private let capW: CGFloat = 34
    private let capH: CGFloat = 34

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(title)
                .font(.caption2)
                .foregroundStyle(Theme.secondary)

            // Base capsule
            RoundedRectangle(cornerRadius: 10, style: .continuous)
                .fill(Theme.surface2)
                .overlay(RoundedRectangle(cornerRadius: 10).stroke(Theme.border, lineWidth: 1))
                .frame(height: 36)
                // Center value gets full width minus reserved edges
                .overlay(
                    Text("\(value)")
                        .font(.headline.monospacedDigit().weight(.semibold))
                        .foregroundStyle(Theme.text)
                        .lineLimit(1)
                        .minimumScaleFactor(0.75)
                        .padding(.horizontal, capW + hPad) // reserve space for the two buttons
                        .frame(maxWidth: .infinity),
                    alignment: .center
                )
                // Left (-)
                .overlay(alignment: .leading) {
                    StepCap(systemName: "minus", width: capW, height: capH) { bump(-1) }
                        //.padding(.leading, hPad)
                }
                // Right (+)
                .overlay(alignment: .trailing) {
                    StepCap(systemName: "plus", width: capW, height: capH) { bump(+1) }
                        //.padding(.trailing, hPad)
                }
        }
    }

    private func bump(_ delta: Int) {
        let newValue = (value + delta).clamped(to: range)
        guard newValue != value else { return }
        value = newValue
        onChange()
        UIImpactFeedbackGenerator(style: .light).impactOccurred()
    }
}

private struct CapsuleStepperDouble: View {
    let title: String
    @Binding var valueDisplay: Double
    let step: Double
    var suffix: String = ""
    var onManualEdit: () -> Void = {}
    

    @State private var editing = false
    @FocusState private var focused: Bool

    // tuning
    private let hPad: CGFloat = 6
    private let capW: CGFloat = 34
    private let capH: CGFloat = 34

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(title)
                .font(.caption2)
                .foregroundStyle(Theme.secondary)

            RoundedRectangle(cornerRadius: 10, style: .continuous)
                .fill(Theme.surface2)
                .overlay(RoundedRectangle(cornerRadius: 10).stroke(Theme.border, lineWidth: 1))
                .frame(height: 36)
                // Center: value or text field
                .overlay(
                    Group {
                        if editing {
                            TextField("0",
                                      value: $valueDisplay,
                                      format: .number.precision(.fractionLength(0...1)))
                                .keyboardType(.decimalPad)
                                .focused($focused)
                                .multilineTextAlignment(.center)
                                .onChange(of: focused) { if !$0 { editing = false } }
                                .onChange(of: valueDisplay) { _ in onManualEdit() }
                        } else {
                            Text("\(valueDisplay, specifier: "%.1f") \(suffix)")
                                .onTapGesture { editing = true }
                        }
                    }
                    .font(.headline.monospacedDigit().weight(.semibold))
                    .foregroundStyle(Theme.text)
                    .lineLimit(1)
                    .minimumScaleFactor(0.75)
                    .padding(.horizontal, capW + hPad) // reserve edges
                    .frame(maxWidth: .infinity),
                    alignment: .center
                )
                .overlay(alignment: .leading) {
                    StepCap(systemName: "minus", width: capW, height: capH) { bump(-step) }
                        //.padding(.leading, hPad)
                }
                .overlay(alignment: .trailing) {
                    StepCap(systemName: "plus", width: capW, height: capH) { bump(+step) }
                       // .padding(.trailing, hPad)
                }
        }
        .toolbar {
            if editing {
                ToolbarItemGroup(placement: .keyboard) {
                    Spacer(); Button("Done") { focused = false; editing = false }
                }
            }
        }
    }

    private func bump(_ delta: Double) {
        let newValue = max(0, valueDisplay + delta)
        guard newValue != valueDisplay else { return }
        valueDisplay = newValue
        onManualEdit()
        UIImpactFeedbackGenerator(style: .light).impactOccurred()
    }
}

// Small, square edge buttons (denser than circles; no layout grab)
private struct StepCap: View {
    let systemName: String
    let width: CGFloat
    let height: CGFloat
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            Image(systemName: systemName)
                .font(.body.weight(.bold))
                .foregroundStyle(Theme.text)
                .frame(width: width, height: height)
                .background(Theme.accent.opacity(0.16), in: RoundedRectangle(cornerRadius: 8, style: .continuous))
                .overlay(RoundedRectangle(cornerRadius: 8).stroke(Theme.border, lineWidth: 1))
        }
        .buttonStyle(.plain)
        .contentShape(Rectangle())
    }
}

private extension Comparable {
    func clamped(to r: ClosedRange<Self>) -> Self { min(max(self, r.lowerBound), r.upperBound) }
}

// MARK: - Set Row (with scroll wheels)

private struct SetRowUnified: View {
    let index: Int
    @Binding var set: SetInput
    let unit: WeightUnit
    let exercise: Exercise
    let isActive: Bool
    let isGhost: Bool
    let onDuplicate: () -> Void
    let onActivate: () -> Void

    @EnvironmentObject private var store: WorkoutStoreV2

    private let defaultWorkingReps = 10
    private var step: Double { unit == .kg ? 2.5 : 5 }
    private var displayWeight: Double { unit == .kg ? set.weight : (set.weight * 2.20462) }

    // Tutorial frame capture callbacks (only for first set)
    var onSetTypeFrameCaptured: ((CGRect) -> Void)? = nil
    var onCarouselsFrameCaptured: ((CGRect) -> Void)? = nil

    var body: some View {
        VStack(spacing: 8) {
            // Header row with index, completion checkmark, and tag
            HStack(spacing: 6) {
                HStack(spacing: 4) {
                    Text("\(index)")
                        .font(.caption.weight(.semibold))
                        .foregroundStyle(isGhost ? Theme.secondary.opacity(0.6) : Theme.secondary)

                    if set.isCompleted {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.caption2)
                            .foregroundStyle(Theme.accent)
                    }
                }
                .frame(width: 32, alignment: .leading)

                //TagDotCycler(tag: $set.tag)
                  //  .fixedSize(horizontal: true, vertical: false)
                  //  .captureFrame(in: .global) { frame in
                    //    onSetTypeFrameCaptured?(frame)
                   // }
                   // .disabled(isGhost)

                Spacer()

                // Ghost indicator
                if isGhost {
                    Text("PLANNED")
                        .font(.caption2.weight(.semibold))
                        .foregroundStyle(Theme.secondary.opacity(0.5))
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Theme.surface2)
                        .clipShape(Capsule())
                }
            }

            // Scroll wheels row with divider
            HStack(spacing: 0) {
                // Reps scroll wheel
                CarouselStepperInt(
                    value: $set.reps,
                    range: 1...50,
                    step: 1,
                    label: "Reps",
                    onChange: {
                        // Disable auto-weight when user manually changes reps
                        set.autoWeight = false
                    }
                )
                .frame(maxWidth: .infinity)
                .disabled(isGhost)

                // Vertical divider
                Rectangle()
                    .fill(Theme.border)
                    .frame(width: 1, height: 40)
                    .padding(.horizontal, 12)

                // Weight scroll wheel
                CarouselStepperDouble(
                    value: Binding(
                        get: { displayWeight },
                        set: { newDisplay in
                            let kg = (unit == .kg) ? max(0, newDisplay) : max(0, newDisplay / 2.20462)
                            set.weight = kg
                        }
                    ),
                    lowerBound: 0,
                    upperBound: unit == .kg ? 300 : 660,
                    step: step,
                    label: "Weight",
                    suffix: unit.rawValue,
                    onManual: { set.autoWeight = false }
                )
                .frame(maxWidth: .infinity)
                .disabled(isGhost)
            }
            .captureFrame(in: .global) { frame in
                onCarouselsFrameCaptured?(frame)
            }
        }
        .padding(.vertical, 10)
        .padding(.horizontal, 8)
        .opacity(set.isCompleted ? 0.6 : (isGhost ? 0.5 : 1.0))
        .background(
            RoundedRectangle(cornerRadius: 10, style: .continuous)
                .stroke(
                    isActive ? Theme.accent : Theme.surface,
                    lineWidth: isActive ? 1 : 1
                )
        )
        .simultaneousGesture(
            TapGesture().onEnded { _ in
                // Tapping any set selects it
                onActivate()
                hideKeyboard()
            }
        )
        .contextMenu {
            Button("Duplicate") { onDuplicate() }
            if !isGhost {
                Button(set.isCompleted ? "Mark Incomplete" : "Mark Complete") {
                    set.isCompleted.toggle()
                }
            }
        }
        .onAppear {
            seedFromMemoryIfNeeded()
            if set.tag == .working { applyWeightSuggestion() }
        }
    }

    private func seedFromMemoryIfNeeded() {
        guard set.tag == .working, set.autoWeight, !set.didSeedFromMemory else { return }
        let looksEmpty = (set.reps == 0 && set.weight == 0)
        guard looksEmpty else { return }
        if let last = store.lastWorkingSet(exercise: exercise) {
            set.reps = last.reps
            set.weight = last.weightKg
            set.didSeedFromMemory = true
            return
        }
        set.reps = (set.reps > 0) ? set.reps : defaultWorkingReps
        set.didSeedFromMemory = true
    }

    private func applyWeightSuggestion() {
        guard set.autoWeight else { return }
        if set.reps <= 0 { set.reps = defaultWorkingReps }
        if let w = store.suggestedWorkingWeight(for: exercise, targetReps: set.reps) {
            let snapped: Double
            if unit == .kg {
                snapped = (w / step).rounded() * step
            } else {
                let lb = w * 2.20462
                snapped = ((lb / step).rounded() * step) / 2.20462
            }
            set.weight = max(0, snapped)
        }
    }
}// ExerciseSessionView.swift ‚Äî replace SetRowCompact with this version

private struct SetRowCompact: View {
    let index: Int
    @Binding var set: SetInput
    let unit: WeightUnit
    let exercise: Exercise
    let onDuplicate: () -> Void

    @EnvironmentObject private var store: WorkoutStoreV2

    private let defaultWorkingReps = 10
    private var step: Double { unit == .kg ? 2.5 : 5 }
    private var displayWeight: Double { unit == .kg ? set.weight : (set.weight * 2.20462) }

    var body: some View {
        HStack(spacing: 8) {
            Text("#\(index)")
                .font(.subheadline.weight(.semibold))
                .foregroundStyle(Theme.secondary)
                .frame(width: 28, alignment: .leading)

            // üëá Tag chip: tap to cycle, long-press for menu
            TagCycler(tag: $set.tag)
                .onChange(of: set.tag) { newTag in
                    if newTag == .working {
                        seedFromMemoryIfNeeded()
                        applyWeightSuggestion()
                    }
                }

            // Reps
            CompactStepperInt(value: $set.reps, label: "Reps", lower: 0, upper: 500)
                .frame(maxWidth: .infinity, alignment: .leading)
                .onChange(of: set.reps) { _ in
                       if set.tag == .working, set.autoWeight {
                           applyWeightSuggestion() // weight only
                       }
                   }

            // Weight
            CompactStepperDouble(
                valueDisplay: Binding(
                    get: { displayWeight },
                    set: { newDisplay in
                        let kg = (unit == .kg) ? max(0, newDisplay) : max(0, newDisplay / 2.20462)
                        set.weight = kg
                    }
                ),
                step: step,
                  label: "Weight",
                  suffix: unit.rawValue,
                  onManualEdit: { set.autoWeight = false }
            )
            .frame(maxWidth: .infinity)
        }
        .padding(.vertical, 8)
        .padding(.trailing, 4)
        .contentShape(Rectangle())
        .contextMenu { Button("Duplicate") { onDuplicate() } }
        .onAppear {
            // First render: if this is a working set and still auto, suggest now.
            if set.tag == .working { applySuggestionsIfAllowed() }
        }
        .onAppear {
                    seedFromMemoryIfNeeded()
                    if set.tag == .working { applyWeightSuggestion() }
                }
    }
    
    private func seedFromMemoryIfNeeded() {
          guard set.tag == .working, set.autoWeight, !set.didSeedFromMemory else { return }
          // only seed when the set looks ‚Äúempty‚Äù
          let looksEmpty = (set.reps == 0 && set.weight == 0)
          guard looksEmpty else { return }

          if let last = store.lastWorkingSet(exercise: exercise) {
              set.reps = last.reps
              set.weight = last.weightKg
              set.didSeedFromMemory = true
              return
          }
          // fallback seed: reps only
          set.reps = (set.reps > 0) ? set.reps : defaultWorkingReps
          set.didSeedFromMemory = true
      }

      // üëá rename & update: only compute WEIGHT based on CURRENT reps.
      private func applyWeightSuggestion() {
          guard set.autoWeight else { return }

          // If reps is zero, give a gentle default
          if set.reps <= 0 { set.reps = defaultWorkingReps }

          if let w = store.suggestedWorkingWeight(for: exercise, targetReps: set.reps) {
              let snapped: Double
              if unit == .kg {
                  snapped = (w / step).rounded() * step
              } else {
                  let lb = w * 2.20462
                  snapped = ((lb / step).rounded() * step) / 2.20462
              }
              set.weight = max(0, snapped)
          }
      }

    private func applySuggestionsIfAllowed() {
        guard set.autoWeight else { return }

        // 1) If we have a very recent working set, prefer copying both reps & weight.
        if let last = store.lastWorkingSet(exercise: exercise) {
            set.reps = last.reps
            set.weight = last.weightKg     // ‚úÖ
            return
        }

        // 2) Otherwise, choose reps then weight conservatively.
        if set.reps <= 0 { set.reps = defaultWorkingReps }

        if let w = store.suggestedWorkingWeight(for: exercise, targetReps: set.reps) {
            // snap to step for nicer UX
            let snapped: Double
            if unit == .kg {
                snapped = (w / step).rounded() * step
            } else {
                let lb = w * 2.20462
                snapped = ((lb / step).rounded() * step) / 2.20462
            }
            set.weight = max(0, snapped)
        }
    }
}

// ExerciseSessionView.swift ‚Äî add this helper view near the other small views

private struct TagCycler: View {
    @Binding var tag: SetTag

    var body: some View {
        let label = tag.label
        Text(label)
            .font(.caption2.weight(.semibold))
            .foregroundStyle(Theme.text)
            .padding(.horizontal, 8)
            .padding(.vertical, 5)
            .background(tag.color, in: Capsule())
            .overlay(Capsule().stroke(Theme.border, lineWidth: 0.75))
            .onTapGesture { cycle() }
            .contextMenu {
                ForEach(SetTag.allCases, id: \.self) { t in
                    Button(t.label) { tag = t }
                }
            }
            .accessibilityLabel("Set type \(label)")
    }

    private func cycle() {
        let all = SetTag.allCases
        if let idx = all.firstIndex(of: tag) {
            let next = all.index(after: idx)
            tag = next < all.endIndex ? all[next] : all.first!
        } else {
            tag = .working
        }
        UIImpactFeedbackGenerator(style: .light).impactOccurred()
    }
}

// MARK: - Compact steppers

private struct CompactStepperInt: View {
    @Binding var value: Int
    let label: String
    let lower: Int
    let upper: Int

    @State private var editing = false
    @FocusState private var focused: Bool

    var body: some View {
        HStack(spacing: 6) {
            Text(label)
                .font(.caption2)
                .foregroundStyle(Theme.secondary)
                .frame(width: 30, alignment: .leading)

            HStack(spacing: 0) {
                Button { bump(-1) } label: { Text("‚àí").font(.headline) }
                    .buttonStyle(CompactKnobStyle())

                Group {
                    if editing {
                        TextField("", value: $value, format: .number)
                            .keyboardType(.numberPad)
                            .focused($focused)
                            .onChange(of: focused) { if !$0 { editing = false } }
                            .multilineTextAlignment(.center)
                            .frame(minWidth: 34, maxWidth: 48)
                            .onAppear { focused = true }
                    } else {
                        Text("\(value)")
                            .font(.callout.monospacedDigit())
                            .foregroundStyle(Theme.text)
                            .frame(minWidth: 34, maxWidth: 48)
                            .onTapGesture { editing = true }
                    }
                }
                .padding(.horizontal, 6)

                Button { bump(+1) } label: { Text("+").font(.headline) }
                    .buttonStyle(CompactKnobStyle())
            }
            .pillBackground()
            .background(Theme.surface2, in: Capsule())
            .overlay(Capsule().stroke(Theme.border, lineWidth: 1))
        }
        .toolbar {
            if editing {
                ToolbarItemGroup(placement: .keyboard) {
                    Spacer()
                    Button("Done") {
                        focused = false
                        editing = false
                    }
                }
            }
        }
    }

    private func bump(_ delta: Int) {
        let newValue = min(upper, max(lower, value + delta))
        if newValue != value {
            value = newValue
            UIImpactFeedbackGenerator(style: .light).impactOccurred()
        }
    }
}

// ExerciseSessionView.swift ‚Äî update CompactStepperDouble signature & call sites

private struct CompactStepperDouble: View {
    @Binding var valueDisplay: Double
    let step: Double
    let label: String
    var suffix: String = ""
    var onManualEdit: () -> Void = {}    // üëà add this

    @State private var editing = false
    @FocusState private var focused: Bool

    var body: some View {
        HStack(spacing: 6) {
            Text(label)
                .font(.caption2)
                .foregroundStyle(Theme.secondary)
                .frame(width: 38, alignment: .leading)

            HStack(spacing: 0) {
                Button {
                    bump(-step)
                    onManualEdit()            // üëà notify
                } label: { Text("‚àí").font(.headline) }
                .buttonStyle(CompactKnobStyle())

                Group {
                    if editing {
                        TextField("",
                                  value: $valueDisplay,
                                  format: .number.precision(.fractionLength(0...1)))
                            .keyboardType(.decimalPad)
                            .focused($focused)
                            .onChange(of: focused) { if !$0 { editing = false } }
                            .onChange(of: valueDisplay) { _ in onManualEdit() } // üëà typing -> manual
                            .multilineTextAlignment(.center)
                            .frame(minWidth: 56, maxWidth: 74)
                            .onAppear { focused = true }
                    } else {
                        Text("\(valueDisplay, specifier: "%.1f")\(suffix.isEmpty ? "" : " \(suffix)")")
                            .font(.callout.monospacedDigit())
                            .foregroundStyle(Theme.text)
                            .frame(minWidth: 56, maxWidth: 74)
                            .minimumScaleFactor(0.9)
                            .lineLimit(1)
                            .onTapGesture { editing = true }
                    }
                }
                .padding(.horizontal, 6)

                Button {
                    bump(+step)
                    onManualEdit()            // üëà notify
                } label: { Text("+").font(.headline) }
                .buttonStyle(CompactKnobStyle())
            }
            .pillBackground()
            .background(Theme.surface2, in: Capsule())
            .overlay(Capsule().stroke(Theme.border, lineWidth: 1))
        }
        .toolbar {
            if editing {
                ToolbarItemGroup(placement: .keyboard) {
                    Spacer()
                    Button("Done") {
                        focused = false
                        editing = false
                    }
                }
            }
        }
    }

    private func bump(_ delta: Double) {
        let newValue = max(0, valueDisplay + delta)
        if newValue != valueDisplay {
            valueDisplay = newValue
            UIImpactFeedbackGenerator(style: .light).impactOccurred()
        }
    }
}

// MARK: - Common styles

private struct PillBackground: ViewModifier {
    func body(content: Content) -> some View {
        content
            .padding(.horizontal, 4)
            .padding(.vertical, 3)
            .background(Theme.surface2, in: Capsule())
            .overlay(Capsule().stroke(Theme.border.opacity(0.9), lineWidth: 0.75))
    }
}
private extension View { func pillBackground() -> some View { modifier(PillBackground()) } }

private struct CompactKnobStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.headline.weight(.semibold))
            .foregroundStyle(Theme.text)
            .frame(width: 28, height: 28)
            .background(Theme.accent.opacity(configuration.isPressed ? 0.26 : 0.18), in: Circle())
            .shadow(color: Theme.accent.opacity(configuration.isPressed ? 0.35 : 0.22),
                    radius: configuration.isPressed ? 6 : 4, x: 0, y: 0)
            .scaleEffect(configuration.isPressed ? 0.96 : 1.0)
            .animation(.easeOut(duration: 0.12), value: configuration.isPressed)
    }
}

// MARK: - CTA

private struct PrimaryCTA: View {
    let title: String
    let action: () -> Void
    var body: some View {
        Button(title, action: action)
            .font(.headline)
            .foregroundStyle(Color.black)
            .frame(maxWidth: .infinity)
            .frame(height: 48)
            .background(Theme.accent)
            .clipShape(RoundedRectangle(cornerRadius: 14, style: .continuous))
    }
}

// MARK: - Muscles section (your existing visuals)

private enum MusclesTheme {
    static let surface  = Color(red: 0.10, green: 0.10, blue: 0.10)
    static let border   = Color.white.opacity(0.10)
    static let headline = Color.white.opacity(0.65)
}

struct ExerciseMusclesSection: View {
    let exercise: Exercise
    var focus: SVGHumanBodyView.Focus = .full

    private var primary: Set<String> { Set(exercise.primaryMuscles.map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }) }
    private var secondary: Set<String> { Set(exercise.secondaryMuscles.map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }) }
    private var tertiary: Set<String> { Set(exercise.tertiaryMuscles.map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }) }

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 14, style: .continuous).fill(MusclesTheme.surface)
            RoundedRectangle(cornerRadius: 14, style: .continuous).stroke(MusclesTheme.border, lineWidth: 1)

            HStack(spacing: 12) {
                SVGHumanBodyView(side: .front, focus: focus, primary: primary, secondary: secondary, tertiary: tertiary)
                    .frame(maxWidth: .infinity)
                    .aspectRatio(0.56, contentMode: .fit)
                SVGHumanBodyView(side: .back,  focus: focus, primary: primary, secondary: secondary, tertiary: tertiary)
                    .frame(maxWidth: .infinity)
                    .aspectRatio(0.56, contentMode: .fit)
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 10)
        }
        .frame(maxWidth: .infinity)
    }
}

// MARK: - SVG body + lexicon (unchanged from your version)

struct SVGHumanBodyView: View {
    enum Side  { case front, back }
    enum Focus { case full, upper, lower }

    var side: Side
    var focus: Focus = .full
    var primary: Set<String> = []
    var secondary: Set<String> = []
    var tertiary: Set<String> = []

    private var highlightKey: String {
        (primary.sorted().joined(separator: ",")) + "|" +
        (secondary.sorted().joined(separator: ",")) + "|" +
        (tertiary.sorted().joined(separator: ","))
    }

    private enum Heatmap {
        static let primaryName   = "mediumorchid"
        static let secondaryName = "orchid"
        static let tertiaryName  = "mediumpurple"
        static let primaryAlpha:   Double = 0.95
        static let secondaryAlpha: Double = 0.55
        static let tertiaryAlpha:  Double = 0.30
    }

    var body: some View {
        Group {
            if let url = Bundle.main.url(forResource: side == .front ? "torso" : "torso_back",
                                         withExtension: "svg") {
                let svg = SVGView(contentsOf: url)
                svg
                    .aspectRatio(contentMode: .fit)
                    .mask(maskForFocus())
                    .onAppear { DispatchQueue.main.async { applyHighlights(into: svg) } }
                    .onChange(of: highlightKey) { _ in DispatchQueue.main.async { applyHighlights(into: svg) } }
                    .onChange(of: side) { _ in DispatchQueue.main.async { applyHighlights(into: svg) } }
                    .onChange(of: focus) { _ in DispatchQueue.main.async { applyHighlights(into: svg) } }
            } else {
                Rectangle().fill(.secondary.opacity(0.15))
                    .overlay(Image(systemName: "exclamationmark.triangle").foregroundStyle(.secondary))
                    .aspectRatio(0.56, contentMode: .fit)
                    .mask(maskForFocus())
            }
        }
    }

    @ViewBuilder
    private func maskForFocus() -> some View {
        GeometryReader { geo in
            let size = geo.size
            let rect: CGRect = {
                switch focus {
                case .full:  return CGRect(origin: .zero, size: size)
                case .upper: return CGRect(x: 0, y: 0, width: size.width, height: size.height * 0.58)
                case .lower: return CGRect(x: 0, y: size.height * 0.42, width: size.width, height: size.height * 0.58)
                }
            }()
            Path { $0.addRect(rect) }.fill(Color.white)
        }
    }

    private func applyHighlights(into root: SVGView) {
        let pTokens = Array(primary).flatMap { MuscleLexicon.tokens(for: $0) }
        let sTokens = Array(secondary).flatMap { MuscleLexicon.tokens(for: $0) }
        let tTokens = Array(tertiary).flatMap { MuscleLexicon.tokens(for: $0) }

        let idx = MuscleIndex.shared
        var pIDs = Set(idx.ids(forClassTokens: pTokens, side: side))
        var sIDs = Set(idx.ids(forClassTokens: sTokens, side: side))
        var tIDs = Set(idx.ids(forClassTokens: tTokens, side: side))

        sIDs.subtract(pIDs)
        tIDs.subtract(pIDs); tIDs.subtract(sIDs)

        color(ids: Array(tIDs), in: root, colorName: Heatmap.tertiaryName, opacity: Heatmap.tertiaryAlpha)
        color(ids: Array(sIDs), in: root, colorName: Heatmap.secondaryName, opacity: Heatmap.secondaryAlpha)
        color(ids: Array(pIDs), in: root, colorName: Heatmap.primaryName,   opacity: Heatmap.primaryAlpha)
    }

    private func paint(_ node: SVGNode, colorName: String, targetOpacity: Double) {
        if let shape = node as? SVGShape {
            shape.fill = SVGColor.by(name: colorName)
            shape.opacity = targetOpacity
        } else if let group = node as? SVGGroup {
            group.opacity = max(group.opacity, targetOpacity)
            for child in group.contents { paint(child, colorName: colorName, targetOpacity: targetOpacity) }
        } else {
            node.opacity = max(node.opacity, targetOpacity)
        }
    }
    private func color(ids: [String], in root: SVGView, colorName: String, opacity: Double) {
        for id in ids { if let node = root.getNode(byId: id) { paint(node, colorName: colorName, targetOpacity: opacity) } }
    }
}

private enum MuscleLexicon {
    static func tokens(for raw: String) -> [String] {
        let base = raw.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        var out: Set<String> = [base, base.replacingOccurrences(of: " ", with: "-"), singularize(base)]
        switch base {
        case "pectoralis major", "pectoralis-major", "chest", "pecs", "pectorals":
            out.formUnion(["pectoralis-major-clavicular","pectoralis-major","chest","pec"])
        case "pectoralis minor", "pectoralis-minor":
            out.formUnion(["pectoralis-minor","chest","pec"])
        case "triceps brachii", "triceps-brachii", "triceps":
            out.formUnion(["triceps","triceps-long","triceps-lateral","triceps-medial"])
        case "biceps brachii", "biceps-brachii":
            out.formUnion(["biceps-brachii-long","biceps-brachii-short","biceps"])
        case "biceps brachii long", "biceps-brachii-long":
            out.formUnion(["biceps-brachii-long","biceps"])
        case "biceps brachii short", "biceps-brachii-short":
            out.formUnion(["biceps-brachii-short","biceps"])
        case "biceps", "bicep":
            out.formUnion(["biceps","biceps-brachii-long","biceps-brachii-short"])
        case "brachialis": out.formUnion(["brachialis"])
        case "brachioradialis": out.formUnion(["brachioradialis"])
        case "forearm flexors", "forearm-flexors", "wrist flexors":
            out.formUnion(["forearm-flexors-1","forearm-flexors-2","forearm-flexors"])
        case "forearm extensors", "forearm-extensors", "wrist extensors":
            out.formUnion(["forearm-extensors","forearm-extensors-1","forearm-extensors-2","forearm-extensors-3"])
        case "supinator": out.formUnion(["supinator"])
        case "deltoid anterior", "anterior deltoid", "anterior deltoids", "deltoid-anterior", "front delts", "front delt":
            out.formUnion(["deltoid-anterior","deltoid","deltoids"])
        case "deltoid posterior", "posterior deltoid", "posterior deltoids", "rear delts", "rear delt", "deltoid-posterior":
            out.formUnion(["deltoid-posterior"])
        case "latissimus dorsi", "lat", "lats", "latissimus-dorsi":
            out.formUnion(["latissimus-dorsi","lats"])
        case "obliques", "external oblique", "internal oblique", "oblique":
            out.formUnion(["obliques"])
        case "rectus abdominis", "abs", "abdominals", "rectus-abdominis":
            out.formUnion(["rectus-abdominis","abs","abdominals"])
        case "serratus anterior", "serratus-anterior":
            out.formUnion(["serratus-anterior"])
        case "subscapularis": out.formUnion(["subscapularis"])
        case "trapezius upper", "upper traps", "trapezius-upper":
            out.formUnion(["trapezius-upper","trapezius","traps"])
        case "trapezius middle", "middle traps", "mid traps", "trapezius-middle":
            out.formUnion(["trapezius-middle"])
        case "trapezius lower", "lower traps", "trapezius-lower":
            out.formUnion(["trapezius-lower"])
        case "splenius", "splenius capitis", "splenius cervicis":
            out.formUnion(["splenius"])
        case "levator scapulae", "levator-scapulae":
            out.formUnion(["levator-scapulae"])
        case "rhomboid", "rhomboids", "rhomboid major", "rhomboid minor":
            out.formUnion(["rhomboid"])
        case "infraspinatus", "teres minor", "teres-minor", "infraspinatus-teres-minor":
            out.formUnion(["infraspinatus-teres-minor","infraspinatus","teres-minor"])
        case "supraspinatus": out.formUnion(["supraspinatus"])
        case "erector spinae", "erectors", "spinal erectors", "erector-spinae":
            out.formUnion(["erector-spinae"])
        case "quadratus lumborum", "quadratus-lumborum":
            out.formUnion(["quadratus-lumborum"])
        case "deep external rotators", "deep-external-rotators", "external rotators":
            out.formUnion(["deep-external-rotators"])
        case "quadriceps", "quads", "quadriceps femoris":
            out.formUnion(["quadriceps","quadriceps-1","quadriceps-2","quadriceps-3","quadriceps-4"])
        case "adductor magnus", "adductor-longus", "adductor longus",
             "adductor brevis", "adductor-brevis",
             "gracilis", "pectineus":
            out.formUnion(["adductors", "hip-adductors", "hip-adductors-1", "hip-adductors-2"])
        case "hip flexors", "hip-flexors": out.formUnion(["hip-flexors"])
        case "abductors", "abductor", "tfl": out.formUnion(["abductors"])
        case "gluteus maximus", "glute max", "gluteus-maximus":
            out.formUnion(["gluteus-maximus"])
        case "hamstrings", "hamstring", "posterior thigh", "posterior-thigh":
            out.formUnion(["hamstrings"])
        case "biceps femoris", "biceps-femoris":
            out.formUnion(["hamstrings","hamstring","biceps-femoris"])
        case "semitendinosus", "semi-tendinosus":
            out.formUnion(["hamstrings","semitendinosus"])
        case "semimembranosus", "semi-membranosus":
            out.formUnion(["hamstrings","semimembranosus"])
        case "gastrocnemius": out.formUnion(["gastrocnemius"])
        case "soleus": out.formUnion(["soleus"])
        case "tibialis anterior", "tibialis-anterior":
            out.formUnion(["tibialis-anterior"])
        default: break
        }
        return Array(out)
    }
    static func idCandidates(forTokens tokens: [String]) -> [String] {
        var ids = Set<String>()
        let sides = ["", "-l", "-r", "-L", "-R", "-left", "-right"]
        let planes = ["", "-front", "-back", "-anterior", "-posterior"]
        let copies = (0...20).map { "-\($0)" } + [""]
        for t in tokens {
            let base = t.trimmingCharacters(in: .whitespacesAndNewlines)
                .lowercased().replacingOccurrences(of: "_", with: "-")
                .replacingOccurrences(of: " ", with: "-")
            let singular = base.hasSuffix("s") ? String(base.dropLast()) : base
            let forms = Set([base, singular])
            for form in forms {
                for s in sides { for p in planes { for c in copies {
                    ids.insert("\(form)\(s)\(p)\(c)")
                    ids.insert("\(form)\(p)\(s)\(c)")
                }}}
            }
        }
        return Array(ids)
    }
    private static func singularize(_ s: String) -> String {
        if s.hasSuffix("s") { return String(s.dropLast()) }
        return s
    }
}

// MARK: - Small helpers

private extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:(a, r, g, b) = (255, 244, 228, 9)
        }
        self.init(.sRGB,
                  red: Double(r) / 255,
                  green: Double(g) / 255,
                  blue: Double(b) / 255,
                  opacity: Double(a) / 255)
    }
}


